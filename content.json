[{"title":"springCloud_Eureka_配置","date":"2020-01-07T06:28:39.000Z","path":"2020/01/07/springCloud-Eureka-配置/","text":"springCloud_Eureka_配置Eureka instance一个服务，如：订单系统，会部署多台服务器，而每台服务器上提供的服务就是instance; 负载配置。 Eureka service指的是服务，提供一种特定功能的服务，如：订单系统，而同一个服务可以提供多个instance; Eureka client主要将自己的服务注册到服务中心。但它既可以是服务的提供者也可以是消费者。它与Eureka instance感觉差不多，但其实意义是不一样的，Eureka client是相较于Eureka server来说的。而Eureka instance更倾向于负载技术。 Eureka server服务注册中心。并管理各服务的中心。 Eureka instance 配置项1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#服务注册中心实例的主机名eureka.instance.hostname=localhost#注册在Eureka服务中的应用组名eureka.instance.app-group-name=#注册在的Eureka服务中的应用名称eureka.instance.appname=#该实例注册到服务中心的唯一IDeureka.instance.instance-id=#该实例的IP地址eureka.instance.ip-address=#该实例，相较于hostname是否优先使用IPeureka.instance.prefer-ip-address=false#用于AWS平台自动扩展的与此实例关联的组名，eureka.instance.a-s-g-name=#部署此实例的数据中心eureka.instance.data-center-info=#默认的地址解析顺序eureka.instance.default-address-resolution-order=#该实例的环境配置eureka.instance.environment=#初始化该实例，注册到服务中心的初始状态eureka.instance.initial-status=up#表明是否只要此实例注册到服务中心，立马就进行通信eureka.instance.instance-enabled-onit=false#该服务实例的命名空间,用于查找属性eureka.instance.namespace=eureka#该服务实例的子定义元数据，可以被服务中心接受到eureka.instance.metadata-map.test = test#服务中心删除此服务实例的等待时间(秒为单位),时间间隔为最后一次服务中心接受到的心跳时间eureka.instance.lease-expiration-duration-in-seconds=90#该实例给服务中心发送心跳的间隔时间，用于表明该服务实例可用eureka.instance.lease-renewal-interval-in-seconds=30#该实例，注册服务中心，默认打开的通信数量eureka.instance.registry.default-open-for-traffic-count=1#每分钟续约次数eureka.instance.registry.expected-number-of-renews-per-min=1#该实例健康检查url,绝对路径eureka.instance.health-check-url=#该实例健康检查url,相对路径eureka.instance.health-check-url-path=/health#该实例的主页url,绝对路径eureka.instance.home-page-url=#该实例的主页url,相对路径eureka.instance.home-page-url-path=/#该实例的安全健康检查url,绝对路径eureka.instance.secure-health-check-url=#https通信端口eureka.instance.secure-port=443#https通信端口是否启用eureka.instance.secure-port-enabled=false#http通信端口eureka.instance.non-secure-port=80#http通信端口是否启用eureka.instance.non-secure-port-enabled=true#该实例的安全虚拟主机名称(https)eureka.instance.secure-virtual-host-name=unknown#该实例的虚拟主机名称(http)eureka.instance.virtual-host-name=unknown#该实例的状态呈现url,绝对路径eureka.instance.status-page-url=#该实例的状态呈现url,相对路径eureka.instance.status-page-url-path=/status Eureka client 配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#该客户端是否可用eureka.client.enabled=true#实例是否在eureka服务器上注册自己的信息以供其他服务发现，默认为trueeureka.client.register-with-eureka=false#此客户端是否获取eureka服务器注册表上的注册信息，默认为trueeureka.client.fetch-registry=false#是否过滤掉，非UP的实例。默认为trueeureka.client.filter-only-up-instances=true#与Eureka注册服务中心的通信zone和url地址eureka.client.serviceUrl.defaultZone=http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/#client连接Eureka服务端后的空闲等待时间，默认为30 秒eureka.client.eureka-connection-idle-timeout-seconds=30#client连接eureka服务端的连接超时时间，默认为5秒eureka.client.eureka-server-connect-timeout-seconds=5#client对服务端的读超时时长eureka.client.eureka-server-read-timeout-seconds=8#client连接all eureka服务端的总连接数，默认200eureka.client.eureka-server-total-connections=200#client连接eureka服务端的单机连接数量，默认50eureka.client.eureka-server-total-connections-per-host=50#执行程序指数回退刷新的相关属性，是重试延迟的最大倍数值，默认为10eureka.client.cache-refresh-executor-exponential-back-off-bound=10#执行程序缓存刷新线程池的大小，默认为5eureka.client.cache-refresh-executor-thread-pool-size=2#心跳执行程序回退相关的属性，是重试延迟的最大倍数值，默认为10eureka.client.heartbeat-executor-exponential-back-off-bound=10#心跳执行程序线程池的大小,默认为5eureka.client.heartbeat-executor-thread-pool-size=5# 询问Eureka服务url信息变化的频率（s），默认为300秒eureka.client.eureka-service-url-poll-interval-seconds=300#最初复制实例信息到eureka服务器所需的时间（s），默认为40秒eureka.client.initial-instance-info-replication-interval-seconds=40#间隔多长时间再次复制实例信息到eureka服务器，默认为30秒eureka.client.instance-info-replication-interval-seconds=30#从eureka服务器注册表中获取注册信息的时间间隔（s），默认为30秒eureka.client.registry-fetch-interval-seconds=30# 获取实例所在的地区。默认为us-east-1eureka.client.region=us-east-1#实例是否使用同一zone里的eureka服务器，默认为true，理想状态下，eureka客户端与服务端是在同一zone下eureka.client.prefer-same-zone-eureka=true# 获取实例所在的地区下可用性的区域列表，用逗号隔开。（AWS）eureka.client.availability-zones.china=defaultZone,defaultZone1,defaultZone2#eureka服务注册表信息里的以逗号隔开的地区名单，如果不这样返回这些地区名单，则客户端启动将会出错。默认为nulleureka.client.fetch-remote-regions-registry=#服务器是否能够重定向客户端请求到备份服务器。 如果设置为false，服务器将直接处理请求，如果设置为true，它可能发送HTTP重定向到客户端。默认为falseeureka.client.allow-redirects=false#客户端数据接收eureka.client.client-data-accept=#增量信息是否可以提供给客户端看，默认为falseeureka.client.disable-delta=false#eureka服务器序列化/反序列化的信息中获取“_”符号的的替换字符串。默认为“__“eureka.client.escape-char-replacement=__#eureka服务器序列化/反序列化的信息中获取“$”符号的替换字符串。默认为“_-”eureka.client.dollar-replacement=&quot;_-&quot;#当服务端支持压缩的情况下，是否支持从服务端获取的信息进行压缩。默认为trueeureka.client.g-zip-content=true#是否记录eureka服务器和客户端之间在注册表的信息方面的差异，默认为falseeureka.client.log-delta-diff=false# 如果设置为true,客户端的状态更新将会点播更新到远程服务器上，默认为trueeureka.client.on-demand-update-status-change=true#此客户端只对一个单一的VIP注册表的信息感兴趣。默认为nulleureka.client.registry-refresh-single-vip-address=#client是否在初始化阶段强行注册到服务中心，默认为falseeureka.client.should-enforce-registration-at-init=false#client在shutdown的时候是否显示的注销服务从服务中心，默认为trueeureka.client.should-unregister-on-shutdown=true# 获取eureka服务的代理主机，默认为nulleureka.client.proxy-host=#获取eureka服务的代理密码，默认为nulleureka.client.proxy-password=# 获取eureka服务的代理端口, 默认为nulleureka.client.proxy-port=# 获取eureka服务的代理用户名，默认为nulleureka.client.proxy-user-name=#属性解释器eureka.client.property-resolver=#获取实现了eureka客户端在第一次启动时读取注册表的信息作为回退选项的实现名称eureka.client.backup-registry-impl=#这是一个短暂的×××的配置，如果最新的×××是稳定的，则可以去除，默认为nulleureka.client.decoder-name=#这是一个短暂的编码器的配置，如果最新的编码器是稳定的，则可以去除，默认为nulleureka.client.encoder-name=#是否使用DNS机制去获取服务列表，然后进行通信。默认为falseeureka.client.use-dns-for-fetching-service-urls=false#获取要查询的DNS名称来获得eureka服务器，此配置只有在eureka服务器ip地址列表是在DNS中才会用到。默认为nulleureka.client.eureka-server-d-n-s-name=#获取eureka服务器的端口，此配置只有在eureka服务器ip地址列表是在DNS中才会用到。默认为nulleureka.client.eureka-server-port=#表示eureka注册中心的路径，如果配置为eureka，则为http://x.x.x.x:x/eureka/，在eureka的配置文件中加入此配置表示eureka作为客户端向注册中心注册，从而构成eureka集群。此配置只有在eureka服务器ip地址列表是在DNS中才会用到，默认为nulleureka.client.eureka-server-u-r-l-context= Eureka Server配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155################server 与 client 关联的配置######################服务端开启自我保护模式。无论什么情况，服务端都会保持一定数量的服务。避免client与server的网络问题，而出现大量的服务被清除。eureka.server.enable-self-preservation=true#开启清除无效服务的定时任务，时间间隔。默认1分钟eureka.server.eviction-interval-timer-in-ms= 60000#间隔多长时间，清除过期的delta数据eureka.server.delta-retention-timer-interval-in-ms=0#过期数据，是否也提供给clienteureka.server.disable-delta=false#eureka服务端是否记录client的身份headereureka.server.log-identity-headers=true#请求频率限制器eureka.server.rate-limiter-burst-size=10#是否开启请求频率限制器eureka.server.rate-limiter-enabled=false#请求频率的平均值eureka.server.rate-limiter-full-fetch-average-rate=100#是否对标准的client进行频率请求限制。如果是false，则只对非标准client进行限制eureka.server.rate-limiter-throttle-standard-clients=false#注册服务、拉去服务列表数据的请求频率的平均值eureka.server.rate-limiter-registry-fetch-average-rate=500#设置信任的client listeureka.server.rate-limiter-privileged-clients=#在设置的时间范围类，期望与client续约的百分比。eureka.server.renewal-percent-threshold=0.85#多长时间更新续约的阈值eureka.server.renewal-threshold-update-interval-ms=0#对于缓存的注册数据，多长时间过期eureka.server.response-cache-auto-expiration-in-seconds=180#多长时间更新一次缓存中的服务注册数据eureka.server.response-cache-update-interval-ms=0#缓存增量数据的时间，以便在检索的时候不丢失信息eureka.server.retention-time-in-m-s-in-delta-queue=0#当时间戳不一致的时候，是否进行同步eureka.server.sync-when-timestamp-differs=true#是否采用只读缓存策略，只读策略对于缓存的数据不会过期。eureka.server.use-read-only-response-cache=true################server 自定义实现的配置######################json的转换的实现类名eureka.server.json-codec-name=#PropertyResolvereureka.server.property-resolver=#eureka server xml的编解码实现名称eureka.server.xml-codec-name=################server node 与 node 之间关联的配置######################发送复制数据是否在request中，总是压缩eureka.server.enable-replicated-request-compression=false#指示群集节点之间的复制是否应批处理以提高网络效率。eureka.server.batch-replication=false#允许备份到备份池的最大复制事件数量。而这个备份池负责除状态更新的其他事件。可以根据内存大小，超时和复制流量，来设置此值得大小eureka.server.max-elements-in-peer-replication-pool=10000#允许备份到状态备份池的最大复制事件数量eureka.server.max-elements-in-status-replication-pool=10000#多个服务中心相互同步信息线程的最大空闲时间eureka.server.max-idle-thread-age-in-minutes-for-peer-replication=15#状态同步线程的最大空闲时间eureka.server.max-idle-thread-in-minutes-age-for-status-replication=15#服务注册中心各个instance相互复制数据的最大线程数量eureka.server.max-threads-for-peer-replication=20#服务注册中心各个instance相互复制状态数据的最大线程数量eureka.server.max-threads-for-status-replication=1#instance之间复制数据的通信时长eureka.server.max-time-for-replication=30000#正常的对等服务instance最小数量。-1表示服务中心为单节点。eureka.server.min-available-instances-for-peer-replication=-1#instance之间相互复制开启的最小线程数量eureka.server.min-threads-for-peer-replication=5#instance之间用于状态复制，开启的最小线程数量eureka.server.min-threads-for-status-replication=1#instance之间复制数据时可以重试的次数eureka.server.number-of-replication-retries=5#eureka节点间间隔多长时间更新一次数据。默认10分钟。eureka.server.peer-eureka-nodes-update-interval-ms=600000#eureka服务状态的相互更新的时间间隔。eureka.server.peer-eureka-status-refresh-time-interval-ms=0#eureka对等节点间连接超时时间eureka.server.peer-node-connect-timeout-ms=200#eureka对等节点连接后的空闲时间eureka.server.peer-node-connection-idle-timeout-seconds=30#节点间的读数据连接超时时间eureka.server.peer-node-read-timeout-ms=200#eureka server 节点间连接的总共最大数量eureka.server.peer-node-total-connections=1000#eureka server 节点间连接的单机最大数量eureka.server.peer-node-total-connections-per-host=10#在服务节点启动时，eureka尝试获取注册信息的次数eureka.server.registry-sync-retries=#在服务节点启动时，eureka多次尝试获取注册信息的间隔时间eureka.server.registry-sync-retry-wait-ms=#当eureka server启动的时候，不能从对等节点获取instance注册信息的情况，应等待多长时间。eureka.server.wait-time-in-ms-when-sync-empty=0################server 与 remote 关联的配置######################过期数据，是否也提供给远程regioneureka.server.disable-delta-for-remote-regions=false#回退到远程区域中的应用程序的旧行为 (如果已配置) 如果本地区域中没有该应用程序的实例, 则将被禁用。eureka.server.disable-transparent-fallback-to-other-region=false#指示在服务器支持的情况下, 是否必须为远程区域压缩从尤里卡服务器获取的内容。eureka.server.g-zip-content-from-remote-region=true#连接eureka remote note的连接超时时间eureka.server.remote-region-connect-timeout-ms=1000#remote region 应用白名单eureka.server.remote-region-app-whitelist.#连接eureka remote note的连接空闲时间eureka.server.remote-region-connection-idle-timeout-seconds=30#执行remote region 获取注册信息的请求线程池大小eureka.server.remote-region-fetch-thread-pool-size=20#remote region 从对等eureka加点读取数据的超时时间eureka.server.remote-region-read-timeout-ms=1000#从remote region 获取注册信息的时间间隔eureka.server.remote-region-registry-fetch-interval=30#remote region 连接eureka节点的总连接数量eureka.server.remote-region-total-connections=1000#remote region 连接eureka节点的单机连接数量eureka.server.remote-region-total-connections-per-host=50#remote region抓取注册信息的存储文件，而这个可靠的存储文件需要全限定名来指定eureka.server.remote-region-trust-store=#remote region 储存的文件的密码eureka.server.remote-region-trust-store-password=#remote region url.多个逗号隔开eureka.server.remote-region-urls=#remote region url.多个逗号隔开eureka.server.remote-region-urls-with-name.################server 与 ASG/AWS/EIP/route52 之间关联的配置######################缓存ASG信息的过期时间。eureka.server.a-s-g-cache-expiry-timeout-ms=0#查询ASG信息的超时时间eureka.server.a-s-g-query-timeout-ms=300#服务更新ASG信息的频率eureka.server.a-s-g-update-interval-ms=0#AWS访问IDeureka.server.a-w-s-access-id=#AWS安全密钥eureka.server.a-w-s-secret-key=#AWS绑定策略eureka.server.binding-strategy=eip#用于从第三方AWS 帐户描述自动扩展分组的角色的名称。eureka.server.list-auto-scaling-groups-role-name=#是否应该建立连接引导eureka.server.prime-aws-replica-connections=true#服务端尝试绑定候选EIP的次数eureka.server.e-i-p-bind-rebind-retries=3#服务端绑定EIP的时间间隔.如果绑定就检查;如果绑定失效就重新绑定。当且仅当已经绑定的情况eureka.server.e-i-p-binding-retry-interval-ms=10#服务端绑定EIP的时间间隔.当且仅当服务为绑定的情况eureka.server.e-i-p-binding-retry-interval-ms-when-unbound=#服务端尝试绑定route53的次数eureka.server.route53-bind-rebind-retries=3#服务端间隔多长时间尝试绑定route53eureka.server.route53-binding-retry-interval-ms=30#eureka.server.route53-domain-t-t-l=10","tags":[{"name":"springCloud eureka","slug":"springCloud-eureka","permalink":"http://yoursite.com/tags/springCloud-eureka/"}]},{"title":"linux新增磁盘","date":"2019-11-26T03:50:08.000Z","path":"2019/11/26/linux新增磁盘/","text":"linux新增磁盘 查看现在已有的分区状态1df –l 查看服务器安装的硬盘状态（包括格式化和未格式化）1fdisk –l 添加新分区123456789101112131415fdisk /dev/sdb按照以下红框输入N 回车P 回车1 回车两次回车W 回车用以下命令查看分区fdisk –l 格式化分区123# mkfs -t ext4 -c /dev/sdb1-t 制定要把磁盘格式化成什么类型-c 在建立文件系统之前检查坏道，可能会很费时间，新硬盘一般不需要 挂载新硬盘1234567在根目录下，建一个文件夹，待会将分区挂载在这个文件夹上，以后要往新硬盘存东西就存在新建文件夹下就可以了。# mkdir /ssd挂载硬盘# mount /dev/sdb1 /ssd 让系统开机自动挂载这块硬盘 1# echo &quot;/dev/sda1 /ssd ext4 defaults 0 0&quot;&gt;&gt;/etc/fstaba","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"linux防火墙开启测试","date":"2019-11-21T01:36:24.000Z","path":"2019/11/21/linux防火墙开启测试/","text":"linux防火墙开启1、防火墙 CentOS升级到7之后，发现无法使用iptables控制Linuxs的端口，google之后发现Centos 7使用firewalld代替了原来的iptables。下面记录如何使用firewalld开放Linux端口： 查看防火墙状态 1systemctl status firewalld 开启防火墙 1systemctl start firewalld 关闭防火墙 1systemctl stop firewalld 查看当前firewall状态 1firewall-cmd --state 重启firewall 1firewall-cmd --reload 禁止开机启动1systemctl disable firewalld.service 2、开启端口 查看已经开放的端口： 1firewall-cmd --list-ports 开启端口 1firewall-cmd --zone=public --add-port=80/tcp --permanent 命令含义： –zone #作用域 –add-port=80/tcp #添加端口，格式为：端口/通讯协议 –permanent #永久生效，没有此参数重启后失效 开启断绝口后需要重启防火墙","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"更改gitlab clone的external_url","date":"2019-11-20T11:01:19.000Z","path":"2019/11/20/更改gitlab-clone的external-url/","text":"更改gitlab clone的external_url在安装gitlab，新建项目之后，默认的clone链接为git@gitlab.example:test/test.git，http也是gitlab.example这种的这样每次clone时候都需要手动改下，改成ip或者域名才可以，可以按照如下方式更改external_url， 直接更改/etc/gitlab/gitlab.rb不能生效，更改/opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml文件(centos7)中host和port即可host可以换成域名，port更改为gitlab服务的端口，这里不设置的话在clone http url时候还是不行，需要把端口加上 12345678910vi /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml # 1. GitLab app settings # ========================== ## GitLab settings gitlab: ## Web server settings (note: host is the FQDN, do not include http://) host: 10.119.116.160 port: 8181 https: false 更改后clone的external_url后执行gitlab-ctl restart，重新进入gitlab就生效了","tags":[{"name":"gitLab","slug":"gitLab","permalink":"http://yoursite.com/tags/gitLab/"}]},{"title":"mideng","date":"2019-11-19T08:35:50.000Z","path":"2019/11/19/mideng/","text":"接口幂等性适用场景及设计方法","tags":[]},{"title":"'mysql查看锁'","date":"2019-09-12T03:26:51.000Z","path":"2019/09/12/mysql查看锁/","text":"mysql查看锁,释放锁第一种 查询是否锁表 1show OPEN TABLES where In_use &gt; 0; 查询进程（如果您有SUPER权限，您可以看到所有线程。否则，您只能看到您自己的线程） 1show processlist 杀死进程id（就是上面命令的id列）1kill id 第二种 查看下在锁的事务 1SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX; 杀死进程id（就是上面命令的trx_mysql_thread_id列） 1kill 线程ID 例子： 查出死锁进程：SHOW PROCESSLIST杀掉进程 KILL 420821; 其它关于查看死锁的命令： 查看当前的事务 1SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX; 查看当前锁定的事务 1SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS; 查看当前等锁的事务 1SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;","tags":[{"name":"mysql ,锁","slug":"mysql-锁","permalink":"http://yoursite.com/tags/mysql-锁/"}]},{"title":"idea_highlight","date":"2019-08-08T01:45:48.000Z","path":"2019/08/08/idea-highlight/","text":"idea 高亮显示依次修改File-settings-Editor-Color Scheme-General菜单下的Code-Identifier under caret和Identifier under caret(write)的Backgroud色值","tags":[{"name":"hightLight","slug":"hightLight","permalink":"http://yoursite.com/tags/hightLight/"}]},{"title":"spring_factoryBean","date":"2019-07-28T04:20:16.000Z","path":"2019/07/28/spring-factoryBean/","text":"spring factoryBean Monkey123package com.melon.app.bean;public class Monkey &#123;&#125; MelonFactoryBean1234567891011121314151617181920package com.melon.app.config;import com.melon.app.bean.Monkey;import org.springframework.beans.factory.FactoryBean;public class MelonFactoryBean implements FactoryBean&lt;Monkey&gt; &#123; public Monkey getObject() throws Exception &#123; return new Monkey(); &#125; public Class&lt;?&gt; getObjectType() &#123; return Monkey.class; &#125; public boolean isSingleton() &#123; return false; &#125;&#125; @Configuration@Import(value = {MelonImportSelector.class,MelonImportBeanDefinitionRegistrar.class})public class MyImportConfigureation { @Bean public MelonFactoryBean melonFactoryBean(){ return new MelonFactoryBean(); } }12345```` ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MyImportConfigureation.class); String[] str= applicationContext.getBeanDefinitionNames(); Object bean1 = applicationContext.getBean(&quot;melonFactoryBean&quot;); System.out.println(bean1.getClass()); 结果如下 class com.melon.app.bean.Monkey org.springframework.context.annotation.internalConfigurationAnnotationProcessor org.springframework.context.annotation.internalAutowiredAnnotationProcessor org.springframework.context.annotation.internalCommonAnnotationProcessor org.springframework.context.event.internalEventListenerProcessor org.springframework.context.event.internalEventListenerFactory myImportConfigureation com.melon.app.bean.Cat com.melon.app.bean.Dog melonFactoryBean pig","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"spring_import","date":"2019-07-28T03:35:44.000Z","path":"2019/07/28/spring-import/","text":"spring import@Import标签使用 一般基本的用import标签使用1@Import(value = &#123;Dog.class&#125;) 2.实现import接口 Cat123package com.melon.app.bean;public class Cat &#123;&#125; Dog123package com.melon.app.bean;public class Dog &#123;&#125; MelonImportSelector实现spring提供的接口package com.melon.app.config; import org.springframework.context.annotation.ImportSelector;import org.springframework.core.type.AnnotationMetadata; public class MelonImportSelector implements ImportSelector { public String[] selectImports(AnnotationMetadata importingClassMetadata) { return new String[]{“com.melon.app.bean.Cat”,”com.melon.app.bean.Dog”}; }} MyImportConfigureation 配置类1234@Configuration@Import(value = &#123;MelonImportSelector.class&#125;)public class MyImportConfigureation &#123;&#125; 测试扫描出来的bean结果如下12345678org.springframework.context.annotation.internalConfigurationAnnotationProcessororg.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.annotation.internalCommonAnnotationProcessororg.springframework.context.event.internalEventListenerProcessororg.springframework.context.event.internalEventListenerFactorymyImportConfigureationcom.melon.app.bean.Catcom.melon.app.bean.Dog importBeanDefintionRegister123456789101112131415161718public class MelonImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123; /** * * @param importingClassMetadata 当前类的注解信息 * @param registry beanDefinition注册类 * 把所有需要添加到容器中的bean加入。 */ public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; boolean bean1 = registry.containsBeanDefinition(&quot;com.melon.app.bean.Dog&quot;); boolean bean2= registry.containsBeanDefinition(&quot;com.melon.app.bean.Cat&quot;); //如果Dog和Cat同时存在于我们IOC容器中，那么创建Pig类，加入到容器 //对于我们要注册的bean,给bean进行封装， if(bean1 &amp;&amp; bean2) &#123; RootBeanDefinition beanDefinition = new RootBeanDefinition(Pig.class); registry.registerBeanDefinition(&quot;pig&quot;,beanDefinition); &#125; &#125;&#125; 1234@Configuration@Import(value = &#123;MelonImportSelector.class,MelonImportBeanDefinitionRegistrar.class&#125;)public class MyImportConfigureation &#123;&#125; 扫描注册bean结果123456789org.springframework.context.annotation.internalConfigurationAnnotationProcessororg.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.annotation.internalCommonAnnotationProcessororg.springframework.context.event.internalEventListenerProcessororg.springframework.context.event.internalEventListenerFactorymyImportConfigureationcom.melon.app.bean.Catcom.melon.app.bean.Dogpig","tags":[{"name":"import","slug":"import","permalink":"http://yoursite.com/tags/import/"}]},{"title":"spring_basic","date":"2019-07-27T13:32:09.000Z","path":"2019/07/27/spring-basic/","text":"spring基础###@Componet#### @RestController @Service 注解等都是基于@component###@componentScan 源码中的useDefaultFilter####12345@Configuration@ComponentScan(value = &quot;com.melon.app&quot;, includeFilters =&#123;@ComponentScan.Filter(type = FilterType.CUSTOM,classes = &#123;MyTypeFilter.class&#125;)&#125;, useDefaultFilters = false) 其中useDefaultFilters为何要设置false的原因就是如果不设置都会扫描@component注解的类源码分析12345678910111213AnnotationConfigApplicationContext-&gt;AbstractApplicationContext.refresh() try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // 调用后置拦截器 invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory);```` &gt;AbstractApplicationContextprotected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory)12//调用后置拦截器&gt;&gt; PostProcessorRegistrationDelegate -&gt;invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); -&gt;invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); -&gt;for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) { postProcessor.postProcessBeanDefinitionRegistry(registry); }1&gt; ConfigureClassPostProcessor -&gt;postProcessBeanDefinitionRegistry -&gt;processConfigBeanDefinitions -&gt; parser.parse(candidates);1&gt; ConfigureClassParser -&gt;parse(Set configCandidates) -&gt;if (bd instanceof AnnotatedBeanDefinition) { parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName()); } -&gt;parse(AnnotationMetadata metadata, String beanName) -&gt;processConfigurationClass(ConfigurationClass configClass) -&gt; doProcessConfigurationClass(configClass, sourceClass); -&gt;Set scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());1&gt; ComponentScanAnnotationParser -&gt;parse(AnnotationAttributes componentScan, final String declaringClass) -&gt;ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry, componentScan.getBoolean(“useDefaultFilters”), this.environment, this.resourceLoader);1&gt; ClassPathBeanDefinitionScanner -&gt;ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters, Environment environment, @Nullable ResourceLoader resourceLoader)123456789101112public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters, Environment environment, @Nullable ResourceLoader resourceLoader) &#123; Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;); this.registry = registry; if (useDefaultFilters) &#123; registerDefaultFilters(); &#125; setEnvironment(environment); setResourceLoader(resourceLoader); &#125; ClassPathScanningCandidateComponentProvider····protected void registerDefaultFilters() { //默认情况下会扫描所有注解是component的类 this.includeFilters.add(new AnnotationTypeFilter(Component.class)); ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader(); try { this.includeFilters.add(new AnnotationTypeFilter( ((Class&lt;? extends Annotation&gt;) ClassUtils.forName(“javax.annotation.ManagedBean”, cl)), false)); logger.trace(“JSR-250 ‘javax.annotation.ManagedBean’ found and supported for component scanning”); } catch (ClassNotFoundException ex) { // JSR-250 1.1 API (as included in Java EE 6) not available - simply skip. } try { this.includeFilters.add(new AnnotationTypeFilter( ((Class&lt;? extends Annotation&gt;) ClassUtils.forName(“javax.inject.Named”, cl)), false)); logger.trace(“JSR-330 ‘javax.inject.Named’ annotation found and supported for component scanning”); } catch (ClassNotFoundException ex) { // JSR-330 API not available - simply skip. } }","tags":[{"name":"spring基础","slug":"spring基础","permalink":"http://yoursite.com/tags/spring基础/"}]},{"title":"springboot_annotation","date":"2019-07-20T13:10:32.000Z","path":"2019/07/20/springboot-annotation/","text":"springBoot @Configuration @Lazy@ComponentScan 使用ComponentScan 就是基本的扫描spring的注解包注意点:如果要用到springboot的Filters属性，那么需要把useDefaultFilters设置成false,否则filter失效@ComponentScan(value=”com.melon.web”,includeFilters={@Filters(type=FilterType.ANNOTATION,classes={Controller.class}},useDefaultFilters=false) 如果useDefaultFilters不设置false，那么includeFilters就不生效，走的是默认的配置，所以一般情况下你要用到Filter就要设置useDefaultFilters=falseFilterType默认按注解过滤 指定注解类型比如@Controller @Filters(type=FilterType.ANNOTATION,classes={Controller.class} 过滤指明具体类 @Filters(type=FilterType.ASSIGNABLE_TYPE,classes={MyController.class} 自定义类型 @Filters(type=FilterType.CUSTOM,classes={MyFilter.class} MyFilter 代码12345678910111213141516171819202122public class MyTypeFilter implements TypeFilter &#123; /** * * @param metadataReader 读取当前正在扫描类的信息 * @param metadataReaderFactory 可以获取到其他任何类信息 * @return * @throws IOException */ public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123; //获取当前类注解的信息 AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); //获取扫描类的信息 ClassMetadata classMetadata = metadataReader.getClassMetadata(); //获取扫描类资源(类路径) Resource resource = metadataReader.getResource(); if(classMetadata.getClassName().contains(&quot;Order&quot;))&#123; return true; &#125; return false; &#125;&#125; @Lazy@Lazy主要跟@Bean搭配，专门针对单列bean,容器起来时候不加载,不生成bean等去getBean的时候再去加载，生成bean","tags":[{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/tags/springboot/"}]},{"title":"python_db","date":"2019-04-26T09:14:59.000Z","path":"2019/04/26/python-db/","text":"1234567891011121314151617181920import cx_Oracleimport ostry: os.environ[&apos;NLS_LANG&apos;] = &apos;SIMPLIFIED CHINESE_CHINA.utf8&apos; db = cx_Oracle.connect(&apos;数据库用户名&apos;, &apos;数据库密码&apos;, &apos;数据库IP地址/数据库实例&apos;) c = db.cursor() ##读取SQL文件,获得sql语句的list with open(u&apos;E:\\\\test.sql&apos;, &apos;r+&apos;) as f: sql_list = f.read().split(&apos;;&apos;)[:-1] # sql文件最后一行加上; sql_list = [x.replace(&apos;\\n&apos;, &apos; &apos;) if &apos;\\n&apos; in x else x for x in sql_list] # 将每段sql里的换行符改成空格 ##执行sql语句，使用循环执行sql语句 for sql_item in sql_list: # print (sql_item) c.execute(sql_item)except cx_Oracle.Error as e: print efinally: c.close() db.commit() db.close() oracle编码问题importlib.reload(sys)os.environ[‘NLS_LANG’] = ‘SIMPLIFIED CHINESE_CHINA.UTF8’","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Hello World","date":"2019-04-16T05:55:15.718Z","path":"2019/04/16/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"apollo","date":"2019-04-16T03:57:23.000Z","path":"2019/04/16/apollo/","text":"apolloapollo","tags":[{"name":"apollo","slug":"apollo","permalink":"http://yoursite.com/tags/apollo/"}]},{"title":"jenkins_jacoco","date":"2019-01-31T01:49:42.000Z","path":"2019/01/31/jenkins-jacoco/","text":"jekins jacoco12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.melon&lt;/groupId&gt; &lt;artifactId&gt;fenmi&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;fenmi&lt;/name&gt; &lt;!-- FIXME change it to the project&apos;s website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jacoco&lt;/groupId&gt; &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.8.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- jacoco plugin --&gt; &lt;plugin&gt; &lt;groupId&gt;org.jacoco&lt;/groupId&gt; &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.7.9&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;!-- 在maven的initialize阶段，将Jacoco的runtime agent作为VM的一个参数 传给被测程序，用于监控JVM中的调用。 --&gt; &lt;id&gt;default-prepare-agent&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;prepare-agent&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;destFile&gt; $&#123;project.build.directory&#125;/coverage-reports/jacoco.exec &lt;/destFile&gt; &lt;propertyName&gt;surefireArgLine&lt;/propertyName&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;!-- 在程序的verify阶段，执行report测试的程序。 文件的输入为perpare-agent阶段中设置或者默认的jacoco.exec. 参数 includes和excludes可用来选定report中过滤的类。 --&gt; &lt;execution&gt; &lt;id&gt;default-report&lt;/id&gt; &lt;phase&gt;test&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;report&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;dataFile&gt;$&#123;project.build.directory&#125;/coverage-reports/jacoco.exec&lt;/dataFile&gt; &lt;outputDirectory&gt;$&#123;project.reporting.outputDirectory&#125;/jacoco&lt;/outputDirectory&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!-- 使用 maven-surefire-plugin来执行单元测试。 将surefireArgLine赋值给argLine参数，以保证在测试执行时Jacoco agent处于运行状态。 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.19.1&lt;/version&gt; &lt;configuration&gt; &lt;argLine&gt;$&#123;surefireArgLine&#125;&lt;/argLine&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;","tags":[{"name":"jenkins","slug":"jenkins","permalink":"http://yoursite.com/tags/jenkins/"}]},{"title":"docker_jenkins","date":"2019-01-29T02:10:20.000Z","path":"2019/01/29/docker-jenkins/","text":"docker jenkins1拉取镜像1docker pull jenkinsci/jenkins 2根据镜像启动容器1docker run -p 8080:8080 -p 50000:50000 jenkinsci/jenkins 3根据提示去查需要初始的密码12docker exec -it 015fad435af29056b08298af455c9dba0f1289be5e03588022736018a1610d70 bash cat /var/jenkins_home/secrets/initialAdminPassword 4根据界面提示去安装插件5安装ssh key连接gitLab这个时候要注意， 配置的公钥私钥来自于jenkins服务器,注意用jenkins账户生成公钥私钥。 在gitLab的deploy key里配置公钥 在jenkins凭据里配置私钥 然后在jenkins服务器上git clone 下地址，用来测试是不是可以连接到gitLab.如果可以证明配置成功。 gitLab","tags":[{"name":"docker jenkins","slug":"docker-jenkins","permalink":"http://yoursite.com/tags/docker-jenkins/"}]},{"title":"docker example","date":"2019-01-25T07:51:26.000Z","path":"2019/01/25/docker-example/","text":"docker example1234$ tree identidock/identidock/└─ app └─ identidock.py identidock.py1234567from flask import Flaskapp = Flask(__name__) @app.route(&apos;/&apos;) def hello_world(): return &apos;Hello World!\\n&apos;if __name__ == &apos;__main__&apos;: app.run(debug=True, host=&apos;0.0.0.0&apos;) 在 identidock 目录下，创建一个名为Dockerfile 的文件12345FROM python:3.4RUN pip install Flask==0.10.1WORKDIR /appCOPY app /appCMD [&quot;python&quot;, &quot;identidock.py&quot;] 现在，可以构建和运行我们的简单应用了：12345$ cd identidock$ docker build -t identidock ....$ docker run -d -p 5000:5000 identidock0c75444e8f5f16dfe5aceb0aae074cc33dfc06f2d2fb6adb773ac51f20605aa4 我把 -d 选项传给 docker run，让它在后台启动容器，但如果想看到 Web 服务器的输出，也可以把它省略。-p 5000:5000 参数告诉 Docker，我们要将容器的 5000 端口转发到主机上的 5000 端口。 test12$ curl localhost:5000Hello World! 目前这个工作流程有一个比较严重的问题：即使代码只有少许改变，我们也需要重新创建镜像，并且重启容器。幸好，有一个简单的解决方法。我们可以把主机上的源码目录绑定挂载（bind mount）到容器内的源码目录之上。 1docker run -d -p 5000:5000 -v &quot;$PWD&quot;/app:/app identidock -v “$PWD”/app:/app 参数把位于 /app 的 app 目录挂载到容器内。它将覆盖容器中 /app 目录的内容 ，而且在容器内还可以进行读写（如果你不希望这样，也可以把数据卷挂载为只读）。参数 -v 必须是绝对路径，因此在这个例子中，我们在当前的目录前加上 $PWD，","tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"docker常用命令","date":"2019-01-25T07:11:13.000Z","path":"2019/01/25/docker常用命令/","text":"docker常用命令_RUN命令 启动新容器时必然会用到它。因此，它是迄今为止最复杂的命令，能支持非常多的参数。它的选项允许用户配置镜像运行的方式、覆盖 Dockerfile 设置、配置联网，以及设置容器的权限和资源。 命令 描述 -a, –attach 把指定的数据流（如 STDOUT 之类）连接至终端。若未指定，则默认连接 stdout 和 stderr。若数据流未指定，而容器以交互模式（-i）启动，则 stdin 也会被连接至终端。此选项与 -d 选项不兼容-d, –detach|使容器在“分离”模式下运行。容器会在后台运行，而命令的返回值是容器的 ID。-i, –interactive|保持 stdin 打开（即使它没有被被连接至终端 10）。一般与 –t 同时使用，用作启动交互式会话的容器。例如：$ docker run -it debian /bin/bashroot@bd0f26f928bb:/# ls…省略… –restart|配置 Docker 在什么情况下尝试重新启动已退出的容器。参数为 no 意味着永远不会尝试重新启动容器；always 指不管退出状态是什么，总会尝试重新启动；on-failure 仅当退出状态不为 0 的时候才会尝试重启 ，并且可以追加一个可选参数，指定尝试重启的次数，超过重启次数就会放弃（如果没有指定，那就一直重试）。例如，docker run–restart on-failure:10 postgres 将启动 postgres 容器，并当退出值不为 0 的时候，尝试重启最多 10 次。–rm|退出时自动删除容器。不能与 -d 选项同时使用。-t, –tty|分配一个伪终端（pseudo-TTY）。通常与 -i 同时使用，用来启动交互式容器。-e, –env|设置容器内的环境变量。例如：$ docker run -e var1=val -e var2=”val 2” debian envPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binHOSTNAME=b15f833d65d8var1=valvar2=val 2HOME=/root另外，–env-file 选项可以经文件传入环境变量。-h, –hostname NAME|设置容器的 unix 主机名为 NAME。例如：$ docker run -h “myhost” debian hostnamemyhost–name NAME|把 NAME 设置为容器的名称。以后，其他 Docker 命令便可以使用该名称来称呼这个容器。以下选项允许用户进行数据卷的设置-v, –volume|这个选项可以用来设置数据卷（数据卷即一个容器中的文件或目录，实际属于主机的文件系统，而非容器的联合文件系统的一部分），有两种形式的参数可供使用。第一种形式仅指定容器中的目录，Docker 会自行选定一个主机上的目录与之绑定。第二种形式除了指定容器目录，还指定与容器目录绑定的主机目录。–volumes-from|挂载指定容器拥有的数据卷。经常用于数据容器–expose|与 Dockerfile 的 EXPOSE 指令功能一样。指定容器将会使用的端口或端口范围，但并不会把端口打开。只有与 -P 参数同时使用，以及在连接容器时，才有真正意义。–link|建立一个与指定容器连接的内部网络接口。详-p, –publish|“发布”容器的端口，使主机能访问它。若没有指定主机端口，则会随机分配一个高端口，可通过 docker port 命令查看分配了哪个端口。还可以指定端口是在主机的哪个网络接口开放。-P, –publish-all|“发布”所有已指定为开放（exposed）的容器端口，使主机能访问它们。每个容器端口均对应一个随机挑选的高端口。docker port 命令可以用来查看端口之间的映射关系。如果你需要更高级的联网功能，还有几个进阶的选项可用。但请注意，这些选项中有一些要求你对联网有一定了解，以及明白联网在 Docker 中如何实现","tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"gitlab备份还原","date":"2019-01-23T02:48:49.000Z","path":"2019/01/23/gitlab备份还原/","text":"备份跟还原 GitLab应用数据备份创建的压缩文件包含了数据库，所有代码仓库和所有附件。你可以在另一个利用同一个版本的gitLab中回复。通过备份跟恢复是迁移你的仓库从一个服务器到另一个的最好的方式。 需要条件为了能够备份跟恢复，你需要在你的系统中安装2个必要的工具。 Rsync(远程同步工具)如果你已经安装了GitLab: 利用OmniBus包 确保rsync都安装 1234# Debian/Ubuntusudo apt-get install rsync# RHEL/CentOSsudo yum install rsync Tar确保Tar命令在1.3.0以上1tar --version 备份timestamp 在 GitLab 9.2 the timestamp 格式变了从EPOCH_YYYY_MM_DD 到 EPOCH_YYYY_MM_DD_GitLab_version,比如 1493107454_2018_04_25 会变成 1493107454_2018_04_25_10.6.4-ce. Gitlab的备份目录路径设置123456789101112[root@code-server ~]# vim /etc/gitlab/gitlab.rbgitlab_rails[&apos;manage_backup_path&apos;] = truegitlab_rails[&apos;backup_path&apos;] = &quot;/data/gitlab/backups&quot; //gitlab备份目录gitlab_rails[&apos;backup_archive_permissions&apos;] = 0644 //生成的备份文件权限gitlab_rails[&apos;backup_keep_time&apos;] = 7776000 //备份保留天数为3个月（即90天，这里是7776000秒） [root@code-server ~]# mkdir -p /data/gitlab/backups[root@code-server ~]# chown -R git.git /data/gitlab/backups[root@code-server ~]# chmod -R 777 /data/gitlab/backups 如上设置了gitlab备份目录路径为/data/gitlab/backups，最后使用下面命令重载gitlab配置文件，是上述修改生效！root@code-server ~]# gitlab-ctl reconfigure GItlab备份操作（使用备份命令”gitlab-rake gitlab:backup:create”）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253手动备份gitlab[root@code-server backups]# gitlab-rake gitlab:backup:createDumping database ...Dumping PostgreSQL database gitlabhq_production ... [DONE]doneDumping repositories ... * treesign/treesign ... [DONE] * gateway/gateway ... [DONE] * treesign/treesign-doc ... [SKIPPED] * qwsign/qwsign ... [DONE] * qwsign/qwsign-doc ... [DONE] * test/test ... [DONE]doneDumping uploads ...doneDumping builds ...doneDumping artifacts ...doneDumping pages ...doneDumping lfs objects ...doneDumping container registry images ...[DISABLED]Creating backup archive: 1510471890_2017_11_12_9.4.5_gitlab_backup.tar ... doneUploading backup archive to remote storage ... skippedDeleting tmp directories ... donedonedonedonedonedonedonedoneDeleting old backups ... done. (0 removed) 然后查看下备份文件（文件权限是设定好的644）[root@code-server backups]# lltotal 244-rw-r--r-- 1 git git 245760 Nov 12 15:33 1510472027_2017_11_12_9.4.5_gitlab_backup.tar 编写备份脚本，结合crontab实施自动定时备份，比如每天0点、6点、12点、18点各备份一次[root@code-server backups]# pwd/data/gitlab/backups[root@code-server backups]# vim gitlab_backup.sh#!/bin/bash/usr/bin/gitlab-rake gitlab:backup:create CRON=1 注意：环境变量CRON=1的作用是如果没有任何错误发生时， 抑制备份脚本的所有进度输出 [root@code-server backups]# crontab -l0 0,6,12,18 * * * /bin/bash -x /data/gitlab/backups/gitlab_backup.sh &gt; /dev/null 2&gt;&amp;1 Gitlab恢复操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189GItlab只能还原到与备份文件相同的gitlab版本。假设在上面gitlab备份之前创建了test项目，然后不小心误删了test项目，现在就进行gitlab恢复操作： 1）停止相关数据连接服务[root@code-server backups]# gitlab-ctl stop unicornok: down: unicorn: 0s, normally up[root@code-server backups]# gitlab-ctl stop sidekiqok: down: sidekiq: 1s, normally up[root@code-server backups]# gitlab-ctl statusrun: gitaly: (pid 98087) 1883s; run: log: (pid 194202) 163003srun: gitlab-monitor: (pid 98101) 1883s; run: log: (pid 194363) 163002srun: gitlab-workhorse: (pid 98104) 1882s; run: log: (pid 194362) 163002srun: logrotate: (pid 98117) 1882s; run: log: (pid 5793) 160832srun: nginx: (pid 98123) 1881s; run: log: (pid 194359) 163002srun: node-exporter: (pid 98167) 1881s; run: log: (pid 194360) 163002srun: postgres-exporter: (pid 98173) 1881s; run: log: (pid 194204) 163003srun: postgresql: (pid 98179) 1880s; run: log: (pid 194365) 163002srun: prometheus: (pid 98187) 1880s; run: log: (pid 194364) 163002srun: redis: (pid 98230) 1879s; run: log: (pid 194358) 163002srun: redis-exporter: (pid 98234) 1879s; run: log: (pid 194208) 163003sdown: sidekiq: 8s, normally up; run: log: (pid 194437) 163001sdown: unicorn: 21s, normally up; run: log: (pid 194443) 163001s 2）现在通过之前的备份文件进行恢复（必须要备份文件放到备份路径下，这里备份路径我自定义的/data/gitlab/backups，默认的是/var/opt/gitlab/backups）[root@code-server backups]# pwd/data/gitlab/backups[root@code-server backups]# lltotal 244-rw-r--r-- 1 git git 245760 Nov 12 15:33 1510472027_2017_11_12_9.4.5_gitlab_backup.tar Gitlab的恢复操作会先将当前所有的数据清空，然后再根据备份数据进行恢复[root@code-server backups]# gitlab-rake gitlab:backup:restore BACKUP=1510472027_2017_11_12_9.4.5Unpacking backup ... doneBefore restoring the database we recommend removing all existingtables to avoid future upgrade problems. Be aware that if you havecustom tables in the GitLab database these tables and all data will beremoved. Do you want to continue (yes/no)?........ALTER TABLEALTER TABLEALTER TABLEALTER TABLEWARNING: no privileges were granted for &quot;public&quot;GRANT[DONE]doneRestoring repositories ... * treesign/treesign ... [DONE] * gateway/gateway ... [DONE] * treesign/treesign-doc ... [DONE] * qwsign/qwsign ... [DONE] * qwsign/qwsign-doc ... [DONE] * test/test ... [DONE]Put GitLab hooks in repositories dirs [DONE]doneRestoring uploads ...doneRestoring builds ...doneRestoring artifacts ...doneRestoring pages ...doneRestoring lfs objects ...doneThis will rebuild an authorized_keys file.You will lose any data stored in authorized_keys file.Do you want to continue (yes/no)? yes Deleting tmp directories ... donedonedonedonedonedonedonedone[root@code-server backups]# 最后再次启动Gitlab[root@code-server backups]# gitlab-ctl startok: run: gitaly: (pid 98087) 2138sok: run: gitlab-monitor: (pid 98101) 2138sok: run: gitlab-workhorse: (pid 98104) 2137sok: run: logrotate: (pid 98117) 2137sok: run: nginx: (pid 98123) 2136sok: run: node-exporter: (pid 98167) 2136sok: run: postgres-exporter: (pid 98173) 2136sok: run: postgresql: (pid 98179) 2135sok: run: prometheus: (pid 98187) 2135sok: run: redis: (pid 98230) 2134sok: run: redis-exporter: (pid 98234) 2134sok: run: sidekiq: (pid 104494) 0sok: run: unicorn: (pid 104497) 1s[root@code-server backups]# gitlab-ctl statusrun: gitaly: (pid 98087) 2142s; run: log: (pid 194202) 163262srun: gitlab-monitor: (pid 98101) 2142s; run: log: (pid 194363) 163261srun: gitlab-workhorse: (pid 98104) 2141s; run: log: (pid 194362) 163261srun: logrotate: (pid 98117) 2141s; run: log: (pid 5793) 161091srun: nginx: (pid 98123) 2140s; run: log: (pid 194359) 163261srun: node-exporter: (pid 98167) 2140s; run: log: (pid 194360) 163261srun: postgres-exporter: (pid 98173) 2140s; run: log: (pid 194204) 163262srun: postgresql: (pid 98179) 2139s; run: log: (pid 194365) 163261srun: prometheus: (pid 98187) 2139s; run: log: (pid 194364) 163261srun: redis: (pid 98230) 2138s; run: log: (pid 194358) 163261srun: redis-exporter: (pid 98234) 2138s; run: log: (pid 194208) 163262srun: sidekiq: (pid 104494) 4s; run: log: (pid 194437) 163260srun: unicorn: (pid 104497) 4s; run: log: (pid 194443) 163260s 恢复命令完成后，可以check检查一下恢复情况[root@code-server backups]# gitlab-rake gitlab:check SANITIZE=trueChecking GitLab Shell ... GitLab Shell version &gt;= 5.3.1 ? ... OK (5.3.1)Repo base directory exists?default... yesRepo storage directories are symlinks?default... noRepo paths owned by git:root, or git:git?default... yesRepo paths access is drwxrws---?default... yeshooks directories in repos are links: ...5/1 ... ok6/2 ... ok5/3 ... repository is empty12/4 ... ok12/5 ... okRunning /opt/gitlab/embedded/service/gitlab-shell/bin/checkCheck GitLab API access: OKAccess to /var/opt/gitlab/.ssh/authorized_keys: OKSend ping to redis server: OKgitlab-shell self-check successful Checking GitLab Shell ... Finished Checking Sidekiq ... Running? ... yesNumber of Sidekiq processes ... 1 Checking Sidekiq ... Finished Checking Reply by email ... Reply by email is disabled in config/gitlab.yml Checking Reply by email ... Finished Checking LDAP ... LDAP is disabled in config/gitlab.yml Checking LDAP ... Finished Checking GitLab ... Git configured correctly? ... yesDatabase config exists? ... yesAll migrations up? ... yesDatabase contains orphaned GroupMembers? ... noGitLab config exists? ... yesGitLab config up to date? ... yesLog directory writable? ... yesTmp directory writable? ... yesUploads directory exists? ... yesUploads directory has correct permissions? ... yesUploads directory tmp has correct permissions? ... yesInit script exists? ... skipped (omnibus-gitlab has no init script)Init script up-to-date? ... skipped (omnibus-gitlab has no init script)Projects have namespace: ...5/1 ... yes6/2 ... yes5/3 ... yes12/4 ... yes12/5 ... yesRedis version &gt;= 2.8.0? ... yesRuby version &gt;= 2.3.3 ? ... yes (2.3.3)Git version &gt;= 2.7.3 ? ... yes (2.13.4)Active users: ... 11 Checking GitLab ... Finished 然后稍等一会（如果启动gitlab后，访问出现500，这是因为redis等程序还没完全启动，等一会儿访问就ok了），再次登录Gitlab，就会发现之前误删除的test项目已经恢复了！ 另外：Gitlab迁移与恢复一样，但是要求两个GitLab版本号一致","tags":[{"name":"gitlab","slug":"gitlab","permalink":"http://yoursite.com/tags/gitlab/"}]},{"title":"gitlab安装","date":"2019-01-18T02:52:55.000Z","path":"2019/01/18/gitlab安装/","text":"gitLab安装1. 配置系统防火墙,把HTTP和SSH端口开放12345[root@gitlab ~]# /etc/init.d/iptables stop[root@gitlab ~]# yum install curl openssh-server postfix cronie[root@gitlab ~]# service postfix start[root@gitlab ~]# chkconfig postfix on[root@gitlab ~]# lokkit -s http -s ssh 2.下载gitlab的rpm安装包1[root@gitlab ~]# rpm -ivh gitlab-ce-9.4.5-ce.0.el6.x86_64.rpm --force 安装后的gitlab默认路径是/opt/gitlab（程序路径）、 /var/opt/gitlab（配置文件路径）。 issue1234[root@localhost zxg]# rpm -ivh gitlab-ce-10.0.0-ce.0.el6.x86_64.rpm --forcewarning: gitlab-ce-10.0.0-ce.0.el6.x86_64.rpm: Header V4 RSA/SHA1 Signature, key ID f27eab47: NOKEYerror: Failed dependencies:policycoreutils-python is needed by gitlab-ce-10.0.0-ce.0.el6.x86_64 solve1yum install policycoreutils-python 3. 配置端口号 vi /etc/gitlab/gitlab.rb12external_url &apos;http://10.60.45.87&apos;nginx[&apos;listen_port&apos;] = 8081 4. 生效123gitlab-ctl reconfiguregitlab-ctl startgitlab-ctl status","tags":[{"name":"gitlab","slug":"gitlab","permalink":"http://yoursite.com/tags/gitlab/"}]},{"title":"gitLab_Runner","date":"2019-01-18T01:27:52.000Z","path":"2019/01/18/gitLab-Runner/","text":"gitLab 之 Runner Gitlab CI Runner安装以及如何跑项目构建流程。 1. 安装、注册并启动Gitlab RunnerGitlab Runner安装方式有两种，一种是直接二进制文件安装，一种是基于docker镜像安装。 1. 下载对应操作系统的二进制包，我这里使用的是mac版本1sudo curl --output /usr/local/bin/gitlab-runner https://gitlab-ci-multi-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-ci-multi-runner-darwin-amd64 1234 # For RHEL/CentOS/Fedora curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.rpm.sh | sudo bash``` ##### 2. 给gitlab-runner赋可执行权限 sudo chmod +x /usr/local/bin/gitlab-runner1##### 3 注册runner gitlab-runner registerPlease enter the gitlab-ci coordinator URL: 示例：http://gitlab.alibaba-inc.com/ciPlease enter the gitlab-ci token for this runner: xxxxxxPlease enter the gitlab-ci description for this runner: 示例：qd_api_runnerPlease enter the gitlab-ci tags for this runner (comma separated): 示例：hwyWhether to run untagged builds [true/false]: truePlease enter the executor: docker, parallels, shell, kubernetes, docker-ssh, ssh, virtualbox, docker+machine, docker-ssh+machine: dockerPlease enter the default Docker image (e.g. ruby:2.1): maven:3-jdk-81234567说明： 1. gitlab ci的地址以及token，从你要配置该runner到哪个项目，就去gitlab下该项目首页右侧设置—》CI/CD Pipelines—》Specific Runners下可以找到。 2. gitlab-ci tags这个很重要，在项目构建流程yaml文件里面指定tag，就是匹配使用哪个tag的runner，这里我定义了hwy，回头再配置文件里面就指定这个tag。 3. executor：执行者可以有很多种，这里我们使用docker，方便构建执行。 4. Docker image：构建Docker image时填写的image名称，根据项目代码语言不同，指定不同的镜像。我这里项目是java语言的，所以我使用官方maven:3-jdk-8镜像。##### 4. 安装并启动gitlab-runner cd ~gitlab-runner installgitlab-runner start` 注册gitlab-runner时，提示报错：GitLab Runner &gt;= 9.0 can be used ONLY with GitLab CE/EE &gt;= 9.0这个因为默认gitlab runner安装时最新版的，与我们正在使用的gitlab版本不匹配，那么我们找到匹配的gitlab-runner版本安装即可，从这里我们可以找到 Runner和GitLab CE / EE兼容性列表有时runner会连接不上，或者在项目仓库-&gt;设置-&gt;runner里呈灰色，这有可能是runner机器上没有启动gitlab-runner引起的，可以执行ps -ef | grep gitlab看看是否存在gitlab-runner的进程，如果没有则执行gitlab-runner start 命令启动runner服务。若已经配置好了gitlab-runner了，执行commit，pipeline状态一直是pending，并且提示：This build is stuck, because the project doesn’t have any runners online assigned to it. Go to Runners page这个是因为未找到对应的runner导致的，原因一是有可能gitlab-runner注册失败，原因二有可能是.gitlab-ci.yml配置文件里面tags没有匹配到已注册可用的runner。每次maven:3-jdk-8去执行build和test都会重新拉取镜像，下载依赖的jar包，比较耗时耗资源。这是因为docker image每次构建都是在独立的container里， maven的 .m2文件并不会被多次构建公用，这里我们可以通过修改gitlab-runner的配置，将maven .m2目录加到volumes中，并增加镜像拉取规则（默认是从远程拉取镜像，这里修改为优先获取本地镜像，不存在时才去远程拉取镜像）","tags":[{"name":"gitLab","slug":"gitLab","permalink":"http://yoursite.com/tags/gitLab/"}]},{"title":"docker_redis","date":"2019-01-16T11:08:22.000Z","path":"2019/01/16/docker-redis/","text":"docker pull redis 1docker run --name myredis -d redis -d d 参数让容器在后台运行 ####启动客户端1234567891011$ docker run --rm -it --link myredis:redis redis /bin/bashroot@ca38735c5747:/data# redis-cli -h redis -p 6379redis:6379&gt; pingPONGredis:6379&gt; set &quot;abc&quot; 123OKredis:6379&gt; get &quot;abc&quot;&quot;123&quot;redis:6379&gt; exitroot@ca38735c5747:/data# exitexit 能将两个容器神奇地连接在一起，是通过 docker run 命令的 –link myredis:redis 参数实现的。这个参数告诉 Docker 把新容器与现存的“myredis”容器连接起来，并且在新容器中以“redis”作为“myredis”容器的主机名。为了实现这一点，Docker 会在新容器中的 /etc/hosts 里添加一个新条目，把“redis”指向“myredis”的 IP 地址。这样就能够在执行redis-cli 的时候直接使用“redis”作为主机名，而不需想办法找出或传递 Redis 容器的 IP地址给 redis-cli。 我们怎样才能做数据的持久保存和备份？为此，我们不会使用标准的容器文件系统，而是需要一个能够让容器与主机，或容器与其他容器之间轻松共享数据的方式。Docker 通过数据卷（volume）的概念提供了这种方式。数据卷是直接在主机挂载的文件或目录，不属于常规联合文件系统的一部分。 第一种是在 Dockerfile 里使用 VOLUME 指令，第二种是在执行docker run 的时候使用 -v 参数。12345678910111213$ docker run --rm -it --link myredis:redis redis /bin/bashroot@09a1c4abf81f:/data# redis-cli -h redis -p 6379redis:6379&gt; set &quot;persistence&quot; &quot;test&quot;OKredis:6379&gt; saveOKredis:6379&gt; exitroot@09a1c4abf81f:/data# exitexit$ docker run --rm --volumes-from myredis -v $(pwd)/backup:/backup \\ debian cp /data/dump.rdb /backup/$ ls backupdump.rdb $ docker stop myredismyredis$ docker rm -v myredis","tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"docker寄存服务","date":"2019-01-16T07:09:44.000Z","path":"2019/01/16/docker寄存服务/","text":"docker寄存服务(registry) 寄存服务（registry）负责托管和发布镜像的服务，默认为 Docker Hub。 仓库（repository）一组相关镜像（通常是一个应用或服务的不同版本）的集合 标签（tag）仓库中镜像的识别号，由英文和数字组成（如 14.04 或 stable）。 MAINTAINER 指令，这样做是为了给镜像设定作者的联系信息12345FROM debianMAINTAINER John Smith &lt;john@smith.com&gt;RUN apt-get update &amp;&amp; apt-get install -y cowsay fortuneCOPY entrypoint.sh /ENTRYPOINT [&quot;/entrypoint.sh&quot;] 构建与push 项目仓库名称必须用你的 Docker Hub 账户名开头（我的是 amouat），12docker build -t amouat/cowsay .docker push amouat/cowsay 加个冒号可以指定标签1docker build -t amouat/cowsay:stable. 上传完毕后，任何人都可以用 docker pull 命令下载你的镜像（例如 docker pull amouat/cowsay）。1docker pull zxg123/cowsay issue: Docker push image: denied 问题：Docker push image: denied: requested accessto the resource is denied 原因：要先docke login再docker push 解决： [root@localhost website]# docker login Login with your Docker ID to push and pullimages from Docker Hub. If you don’t have a Docker ID, head over tohttps://hub.docker.com to create one. Username: lilei123 Password: Login Succeeded","tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"docker dockerFile","date":"2019-01-16T05:37:08.000Z","path":"2019/01/16/docker-dockerFile/","text":"dockerFile利用 Dockerfile，使创建镜像的过程全部自动化。 Dockerfile Dockerfile 是一个描述如何创建 Docker 镜像所需步骤的文本文件。 123$ mkdir cowsay $ cd cowsay $ touch Dockerfile 编辑Dockerfile12FROM debian:wheezyRUN apt-get update &amp;&amp; apt-get install -y cowsay fortune 执行Dockerfile123$ lsDockerfile$ docker build -t test/cowsay-dockerfile . 最后面那个点代表当前目录下执行docker build创建成功,执行docker1$ docker run test/cowsay-dockerfile /usr/games/cowsay &quot;Moo&quot; 通过利用 Dockerfile 的 ENTRYPOINT 指 令, 我 们 可 以 让 用 户 更 易 于 使 用 这 个 镜 像。ENTRYPOINT 指令让我们指定一个可执行文件，同时还能处理传给 docker run 的参数。在 Dockerfile 的最后加上下面这一行： 1ENTRYPOINT [&quot;/usr/games/cowsay&quot;] 现在再次生成新镜像，以后使用这个新镜像时再也不需要指定 cowsay 命令了： 123$ docker build -t test/cowsay-dockerfile .$ docker run test/cowsay-dockerfile &quot;Moo&quot; 我们可以把 ENTRYPOINT 指定为一个我们自己的脚本创建一个新文件 entrypoint.sh123456#!/bin/bashif [ $# -eq 0 ]; then /usr/games/fortune | /usr/games/cowsay else /usr/games/cowsay &quot;$@&quot;fi 用 chmod +x entrypoint.sh 把文件设为可执行 修改DockerFile1234FROM debianRUN apt-get update &amp;&amp; apt-get install -y cowsay fortuneCOPY entrypoint.sh / ENTRYPOINT [&quot;/entrypoint.sh&quot;] 测试执行123docker build -t test/cowsay-dockerfile .docker run test/cowsay-dockerfiledocker run test/cowsay-dockerfile Hello Moo","tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"docker容器运行apt-get update失败Temporary failure resolving","date":"2019-01-16T03:45:04.000Z","path":"2019/01/16/docker容器运行apt-get-update失败Temporary-failure-resolving/","text":"Ubuntu中docker容器运行apt-get update失败Temporary failure resolving1sudo systemctl restart docker 试过了添加nameserver到/etc/resolve.conf还是不行，最后重启docker，问题解决了。。。 一开始是简单粗暴地改写域名解析文件：1python -c &quot;s=&apos;nameserver 114.114.114.114&apos;;fname=&apos;/etc/resolv.conf&apos;;fp=open(fname);ss=fp.read();fp.close();fp=open(fname, &apos;w&apos;);fp.write(&apos;&#123;s&#125;\\n&#123;ss&#125;&apos;.format(s=s,ss=ss));fp.close()&quot; 结果在容器运行时有作用，在创建容器时还是会出问题，所以还是要重启docker","tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"docker IPv4 forwarding is disabled","date":"2019-01-16T02:42:27.000Z","path":"2019/01/16/docker-IPv4-forwarding-is-disabled/","text":"centos 7 docker 启动了一个web服务 但是启动时 报 WARNING: IPv4 forwarding is disabled. Networking will not work. 网上查询了下 需要做如下配置 解决办法： vi /etc/sysctl.conf 或者 vi /usr/lib/sysctl.d/00-system.conf 添加如下代码： net.ipv4.ip_forward=1 重启network服务 systemctl restart network 查看是否修改成功 sysctl net.ipv4.ip_forward 如果返回为“net.ipv4.ip_forward = 1”则表示成功了","tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"linux iptables","date":"2019-01-16T02:25:29.000Z","path":"2019/01/16/linux-iptables/","text":"解决centos7中使用service iptables stop 显示not loadedcentos从7开始默认用的是firewalld，这个是基于iptables的，虽然有iptables的核心，但是iptables的服务是没安装的。所以你只要停止firewalld服务即可：sudo systemctl stop firewalld.service &amp;&amp; sudo systemctl disable firewalld.service 如果你要改用iptables的话，需要安装iptables服务：sudo yum install iptables-servicessudo systemctl enable iptables &amp;&amp; sudo systemctl enable ip6tablessudo systemctl start iptables &amp;&amp; sudo systemctl start ip6tables","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"docker基本命令","date":"2019-01-15T12:33:17.000Z","path":"2019/01/15/docker基本命令/","text":"sonar为容器名称 1docker inspect sonar sonar容器信息 1docker diff sonar sonar容器最近修改信息 1234docker logs sonardocker logs -t sonardocker logs -tf sonardocker logs -tf --tail 0 sonar sonar删除容器 1docker rm sonar 清理已停止的容器 1docker rm -v $(docker ps -aq -f status=exited) 在运行中的容器内启动新进程 1docker exec -i -t container /bin/bash 把cowsay应用docker化 123456789101112131415161718192021222324 docker run -it --name cowsay --hostname cowsay debian bash apt-get update apt-get install -y cowsay fortune /usr/games/fortune | /usr/games/cowsay / Writing is easy; all you do is sit \\| staring at the blank sheet of paper || until drops of blood form on your || forehead. || |\\ -- Gene Fowler / ------------------------------------- \\ ^__^ \\ (oo)\\_______ (__)\\ )\\/\\ ||---w | || || 要把它转成镜像的话，执行 docker commit cowsay test/cowsayimage 命令的返回值是这个镜像的唯一识别码（unique ID）。现在，我们创建了一个能随时使用， 并且已安装 cowsay 的镜像： docker run test/cowsayimage /usr/games/cowsay &quot;Moo&quot;","tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"linux常用命令","date":"2019-01-14T09:45:53.000Z","path":"2019/01/14/linux常用命令/","text":"######## linux 常用命令 ######网络断了启动网络 service network startkill -9 ps -ef|grep firefox|grep -v grep|awk &#39;{print $2}&#39; 查看某端口占用的线程的pid netstat -nlp |grep :9181","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"docker_python","date":"2019-01-11T07:38:36.000Z","path":"2019/01/11/docker-python/","text":"docker run -v $PWD:/usr/src/myapp -w /usr/src/myapp python:3.5 python helloworld.py","tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"docker安装 mysql","date":"2019-01-10T02:16:06.000Z","path":"2019/01/10/docker/","text":"docker 安装 mysql‘’’ docker 中下载 mysqldocker pull mysql #启动docker run –name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=Lzslov123! -d mysql #进入容器docker exec -it mysql bash #登录mysqlmysql -u root -pALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘Lzslov123!’; #添加远程登录用户CREATE USER ‘liaozesong‘@’%’ IDENTIFIED WITH mysql_native_password BY ‘Lzslov123!’;或者 CREATE USER ‘liaozesong‘@’%’ IDENTIFIED BY ‘Lzslov123!’;GRANT ALL PRIVILEGES ON . TO ‘liaozesong‘@’%’;‘’’","tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"centos7","date":"2019-01-09T09:17:58.000Z","path":"2019/01/09/centos7/","text":"centos7 初始化安装刚开始安装用mini版本，所以很多需要安装的库都没安装，首先会出现输入ifconfig没有对应的值ifconfig1yum install net-tools","tags":[{"name":"centos7,linux","slug":"centos7-linux","permalink":"http://yoursite.com/tags/centos7-linux/"}]},{"title":"python_os 详解","date":"2019-01-09T09:17:58.000Z","path":"2019/01/09/python_os/","text":"获取项目根目录绝对路径‘’’projectDir = os.path.dirname(os.path.dirname(os.path.abspath(file)))‘’’ python 初始化安装os.sep:取代操作系统特定的路径分隔符os.name:指示你正在使用的工作平台。比如对于Windows，它是’nt’，而对于Linux/Unix用户，它是’posix’。os.getcwd:得到当前工作目录，即当前python脚本工作的目录路径。os.getenv()和os.putenv:分别用来读取和设置环境变量os.listdir():返回指定目录下的所有文件和目录名os.remove(file):删除一个文件os.stat（file）:获得文件属性os.chmod(file):修改文件权限和时间戳os.mkdir(name):创建目录os.rmdir(name):删除目录os.removedirs（r“c：\\python”）:删除多个目录os.system():运行shell命令os.exit():终止当前进程os.linesep:给出当前平台的行终止符。例如，Windows使用’\\r\\n’，Linux使用’\\n’而Mac使用’\\r’os.path.split():返回一个路径的目录名和文件名os.path.isfile()和os.path.isdir()分别检验给出的路径是一个目录还是文件os.path.existe():检验给出的路径是否真的存在os.listdir(dirname):列出dirname下的目录和文件os.getcwd():获得当前工作目录os.curdir:返回当前目录（’.’）os.chdir(dirname):改变工作目录到dirnameos.path.isdir(name):判断name是不是目录，不是目录就返回falseos.path.isfile(name):判断name这个文件是否存在，不存在返回falseos.path.exists(name):判断是否存在文件或目录nameos.path.getsize(name):或得文件大小，如果name是目录返回0Los.path.abspath(name):获得绝对路径os.path.isabs():判断是否为绝对路径os.path.normpath(path):规范path字符串形式os.path.split(name):分割文件名与目录（事实上，如果你完全使用目录，它也会将最后一个目录作为文件名而分离，同时它不会判断文件或目录是否存在）os.path.splitext():分离文件名和扩展名os.path.join(path,name):连接目录与文件名或目录os.path.basename(path):返回文件名os.path.dirname(path):返回文件路径 文件操作os.mknod(“text.txt”)：创建空文件fp = open(“text.txt”,w):直接打开一个文件，如果文件不存在就创建文件 关于open的模式fp.read([size]) #size为读取的长度，以byte为单位fp.readline([size]) #读一行，如果定义了size，有可能返回的只是一行的一部分fp.readlines([size]) #把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。fp.write(str) #把str写到文件中，write()并不会在str后加上一个换行符fp.writelines(seq) #把seq的内容全部写到文件中(多行一次性写入)。这个函数也只是忠实地写入，不会在每行后面加上任何东西。fp.close() #关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。 如果一个文件在关闭后还对其进行操作会产生ValueErrorfp.flush() #把缓冲区的内容写入硬盘fp.fileno() #返回一个长整型的”文件标签“fp.isatty() #文件是否是一个终端设备文件（unix系统中的）fp.tell() #返回文件操作标记的当前位置，以文件的开头为原点fp.next() #返回下一行，并将文件操作标记位移到下一行。把一个file用于for … in file这样的语句时，就是调用next()函数来实现遍历的。fp.seek(offset[,whence]) #将文件打操作标记移到offset的位置。这个offset一般是相对于文件的开头来计算的，一般为正数。但如果提供了whence参数就不一定了，whence可以为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。需要注意，如果文件以a或a+的模式打开，每次进行写操作时，文件操作标记会自动返回到文件末尾。fp.truncate([size]) #把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。如果size比文件的大小还要大，依据系统的不同可能是不改变文件，也可能是用0把文件补到相应的大小，也可能是以一些随机的内容加上去。 目录操作os.mkdir(“file”) 创建目录shutil.copyfile(“oldfile”,”newfile”) 复制文件:oldfile和newfile都只能是文件shutil.copy(“oldfile”,”newfile”) oldfile只能是文件夹，newfile可以是文件，也可以是目标目录shutil.copytree(“olddir”,”newdir”) 复制文件夹.olddir和newdir都只能是目录，且newdir必须不存在os.rename(“oldname”,”newname”) 重命名文件（目录）.文件或目录都是使用这条命令shutil.move(“oldpos”,”newpos”) 移动文件（目录os.rmdir(“dir”) 只能删除空目录shutil.rmtree(“dir”) 空目录、有内容的目录都可以删os.chdir(“path”) 转换目录，换路径","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]}]