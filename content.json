[{"title":"idea_highlight","date":"2019-08-08T01:45:48.000Z","path":"2019/08/08/idea-highlight/","text":"idea 高亮显示依次修改File-settings-Editor-Color Scheme-General菜单下的Code-Identifier under caret和Identifier under caret(write)的Backgroud色值","tags":[{"name":"hightLight","slug":"hightLight","permalink":"http://yoursite.com/tags/hightLight/"}]},{"title":"spring_factoryBean","date":"2019-07-28T04:20:16.000Z","path":"2019/07/28/spring-factoryBean/","text":"spring factoryBean Monkey123package com.melon.app.bean;public class Monkey &#123;&#125; MelonFactoryBean1234567891011121314151617181920package com.melon.app.config;import com.melon.app.bean.Monkey;import org.springframework.beans.factory.FactoryBean;public class MelonFactoryBean implements FactoryBean&lt;Monkey&gt; &#123; public Monkey getObject() throws Exception &#123; return new Monkey(); &#125; public Class&lt;?&gt; getObjectType() &#123; return Monkey.class; &#125; public boolean isSingleton() &#123; return false; &#125;&#125; @Configuration@Import(value = {MelonImportSelector.class,MelonImportBeanDefinitionRegistrar.class})public class MyImportConfigureation { @Bean public MelonFactoryBean melonFactoryBean(){ return new MelonFactoryBean(); } }12345```` ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MyImportConfigureation.class); String[] str= applicationContext.getBeanDefinitionNames(); Object bean1 = applicationContext.getBean(&quot;melonFactoryBean&quot;); System.out.println(bean1.getClass()); 结果如下 class com.melon.app.bean.Monkey org.springframework.context.annotation.internalConfigurationAnnotationProcessor org.springframework.context.annotation.internalAutowiredAnnotationProcessor org.springframework.context.annotation.internalCommonAnnotationProcessor org.springframework.context.event.internalEventListenerProcessor org.springframework.context.event.internalEventListenerFactory myImportConfigureation com.melon.app.bean.Cat com.melon.app.bean.Dog melonFactoryBean pig","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"spring_import","date":"2019-07-28T03:35:44.000Z","path":"2019/07/28/spring-import/","text":"spring import@Import标签使用 一般基本的用import标签使用1@Import(value = &#123;Dog.class&#125;) 2.实现import接口 Cat123package com.melon.app.bean;public class Cat &#123;&#125; Dog123package com.melon.app.bean;public class Dog &#123;&#125; MelonImportSelector实现spring提供的接口package com.melon.app.config; import org.springframework.context.annotation.ImportSelector;import org.springframework.core.type.AnnotationMetadata; public class MelonImportSelector implements ImportSelector { public String[] selectImports(AnnotationMetadata importingClassMetadata) { return new String[]{“com.melon.app.bean.Cat”,”com.melon.app.bean.Dog”}; }} MyImportConfigureation 配置类1234@Configuration@Import(value = &#123;MelonImportSelector.class&#125;)public class MyImportConfigureation &#123;&#125; 测试扫描出来的bean结果如下12345678org.springframework.context.annotation.internalConfigurationAnnotationProcessororg.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.annotation.internalCommonAnnotationProcessororg.springframework.context.event.internalEventListenerProcessororg.springframework.context.event.internalEventListenerFactorymyImportConfigureationcom.melon.app.bean.Catcom.melon.app.bean.Dog importBeanDefintionRegister123456789101112131415161718public class MelonImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123; /** * * @param importingClassMetadata 当前类的注解信息 * @param registry beanDefinition注册类 * 把所有需要添加到容器中的bean加入。 */ public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; boolean bean1 = registry.containsBeanDefinition(&quot;com.melon.app.bean.Dog&quot;); boolean bean2= registry.containsBeanDefinition(&quot;com.melon.app.bean.Cat&quot;); //如果Dog和Cat同时存在于我们IOC容器中，那么创建Pig类，加入到容器 //对于我们要注册的bean,给bean进行封装， if(bean1 &amp;&amp; bean2) &#123; RootBeanDefinition beanDefinition = new RootBeanDefinition(Pig.class); registry.registerBeanDefinition(&quot;pig&quot;,beanDefinition); &#125; &#125;&#125; 1234@Configuration@Import(value = &#123;MelonImportSelector.class,MelonImportBeanDefinitionRegistrar.class&#125;)public class MyImportConfigureation &#123;&#125; 扫描注册bean结果123456789org.springframework.context.annotation.internalConfigurationAnnotationProcessororg.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.annotation.internalCommonAnnotationProcessororg.springframework.context.event.internalEventListenerProcessororg.springframework.context.event.internalEventListenerFactorymyImportConfigureationcom.melon.app.bean.Catcom.melon.app.bean.Dogpig","tags":[{"name":"import","slug":"import","permalink":"http://yoursite.com/tags/import/"}]},{"title":"spring_basic","date":"2019-07-27T13:32:09.000Z","path":"2019/07/27/spring-basic/","text":"spring基础###@Componet#### @RestController @Service 注解等都是基于@component###@componentScan 源码中的useDefaultFilter####12345@Configuration@ComponentScan(value = &quot;com.melon.app&quot;, includeFilters =&#123;@ComponentScan.Filter(type = FilterType.CUSTOM,classes = &#123;MyTypeFilter.class&#125;)&#125;, useDefaultFilters = false) 其中useDefaultFilters为何要设置false的原因就是如果不设置都会扫描@component注解的类源码分析12345678910111213AnnotationConfigApplicationContext-&gt;AbstractApplicationContext.refresh() try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // 调用后置拦截器 invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory);```` &gt;AbstractApplicationContextprotected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory)12//调用后置拦截器&gt;&gt; PostProcessorRegistrationDelegate -&gt;invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); -&gt;invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); -&gt;for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) { postProcessor.postProcessBeanDefinitionRegistry(registry); }1&gt; ConfigureClassPostProcessor -&gt;postProcessBeanDefinitionRegistry -&gt;processConfigBeanDefinitions -&gt; parser.parse(candidates);1&gt; ConfigureClassParser -&gt;parse(Set configCandidates) -&gt;if (bd instanceof AnnotatedBeanDefinition) { parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName()); } -&gt;parse(AnnotationMetadata metadata, String beanName) -&gt;processConfigurationClass(ConfigurationClass configClass) -&gt; doProcessConfigurationClass(configClass, sourceClass); -&gt;Set scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());1&gt; ComponentScanAnnotationParser -&gt;parse(AnnotationAttributes componentScan, final String declaringClass) -&gt;ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry, componentScan.getBoolean(“useDefaultFilters”), this.environment, this.resourceLoader);1&gt; ClassPathBeanDefinitionScanner -&gt;ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters, Environment environment, @Nullable ResourceLoader resourceLoader)123456789101112public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters, Environment environment, @Nullable ResourceLoader resourceLoader) &#123; Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;); this.registry = registry; if (useDefaultFilters) &#123; registerDefaultFilters(); &#125; setEnvironment(environment); setResourceLoader(resourceLoader); &#125; ClassPathScanningCandidateComponentProvider····protected void registerDefaultFilters() { //默认情况下会扫描所有注解是component的类 this.includeFilters.add(new AnnotationTypeFilter(Component.class)); ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader(); try { this.includeFilters.add(new AnnotationTypeFilter( ((Class&lt;? extends Annotation&gt;) ClassUtils.forName(“javax.annotation.ManagedBean”, cl)), false)); logger.trace(“JSR-250 ‘javax.annotation.ManagedBean’ found and supported for component scanning”); } catch (ClassNotFoundException ex) { // JSR-250 1.1 API (as included in Java EE 6) not available - simply skip. } try { this.includeFilters.add(new AnnotationTypeFilter( ((Class&lt;? extends Annotation&gt;) ClassUtils.forName(“javax.inject.Named”, cl)), false)); logger.trace(“JSR-330 ‘javax.inject.Named’ annotation found and supported for component scanning”); } catch (ClassNotFoundException ex) { // JSR-330 API not available - simply skip. } }","tags":[{"name":"spring基础","slug":"spring基础","permalink":"http://yoursite.com/tags/spring基础/"}]},{"title":"springboot_annotation","date":"2019-07-20T13:10:32.000Z","path":"2019/07/20/springboot-annotation/","text":"springBoot @Configuration @Lazy@ComponentScan 使用ComponentScan 就是基本的扫描spring的注解包注意点:如果要用到springboot的Filters属性，那么需要把useDefaultFilters设置成false,否则filter失效@ComponentScan(value=”com.melon.web”,includeFilters={@Filters(type=FilterType.ANNOTATION,classes={Controller.class}},useDefaultFilters=false) 如果useDefaultFilters不设置false，那么includeFilters就不生效，走的是默认的配置，所以一般情况下你要用到Filter就要设置useDefaultFilters=falseFilterType默认按注解过滤 指定注解类型比如@Controller @Filters(type=FilterType.ANNOTATION,classes={Controller.class} 过滤指明具体类 @Filters(type=FilterType.ASSIGNABLE_TYPE,classes={MyController.class} 自定义类型 @Filters(type=FilterType.CUSTOM,classes={MyFilter.class} MyFilter 代码12345678910111213141516171819202122public class MyTypeFilter implements TypeFilter &#123; /** * * @param metadataReader 读取当前正在扫描类的信息 * @param metadataReaderFactory 可以获取到其他任何类信息 * @return * @throws IOException */ public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123; //获取当前类注解的信息 AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); //获取扫描类的信息 ClassMetadata classMetadata = metadataReader.getClassMetadata(); //获取扫描类资源(类路径) Resource resource = metadataReader.getResource(); if(classMetadata.getClassName().contains(&quot;Order&quot;))&#123; return true; &#125; return false; &#125;&#125; @Lazy@Lazy主要跟@Bean搭配，专门针对单列bean,容器起来时候不加载,不生成bean等去getBean的时候再去加载，生成bean","tags":[{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/tags/springboot/"}]},{"title":"python_db","date":"2019-04-26T09:14:59.000Z","path":"2019/04/26/python-db/","text":"1234567891011121314151617181920import cx_Oracleimport ostry: os.environ[&apos;NLS_LANG&apos;] = &apos;SIMPLIFIED CHINESE_CHINA.utf8&apos; db = cx_Oracle.connect(&apos;数据库用户名&apos;, &apos;数据库密码&apos;, &apos;数据库IP地址/数据库实例&apos;) c = db.cursor() ##读取SQL文件,获得sql语句的list with open(u&apos;E:\\\\test.sql&apos;, &apos;r+&apos;) as f: sql_list = f.read().split(&apos;;&apos;)[:-1] # sql文件最后一行加上; sql_list = [x.replace(&apos;\\n&apos;, &apos; &apos;) if &apos;\\n&apos; in x else x for x in sql_list] # 将每段sql里的换行符改成空格 ##执行sql语句，使用循环执行sql语句 for sql_item in sql_list: # print (sql_item) c.execute(sql_item)except cx_Oracle.Error as e: print efinally: c.close() db.commit() db.close() oracle编码问题importlib.reload(sys)os.environ[‘NLS_LANG’] = ‘SIMPLIFIED CHINESE_CHINA.UTF8’","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Hello World","date":"2019-04-16T05:55:15.718Z","path":"2019/04/16/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"apollo","date":"2019-04-16T03:57:23.000Z","path":"2019/04/16/apollo/","text":"apolloapollo","tags":[{"name":"apollo","slug":"apollo","permalink":"http://yoursite.com/tags/apollo/"}]},{"title":"jenkins_jacoco","date":"2019-01-31T01:49:42.000Z","path":"2019/01/31/jenkins-jacoco/","text":"jekins jacoco12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.melon&lt;/groupId&gt; &lt;artifactId&gt;fenmi&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;fenmi&lt;/name&gt; &lt;!-- FIXME change it to the project&apos;s website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jacoco&lt;/groupId&gt; &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.8.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- jacoco plugin --&gt; &lt;plugin&gt; &lt;groupId&gt;org.jacoco&lt;/groupId&gt; &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.7.9&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;!-- 在maven的initialize阶段，将Jacoco的runtime agent作为VM的一个参数 传给被测程序，用于监控JVM中的调用。 --&gt; &lt;id&gt;default-prepare-agent&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;prepare-agent&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;destFile&gt; $&#123;project.build.directory&#125;/coverage-reports/jacoco.exec &lt;/destFile&gt; &lt;propertyName&gt;surefireArgLine&lt;/propertyName&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;!-- 在程序的verify阶段，执行report测试的程序。 文件的输入为perpare-agent阶段中设置或者默认的jacoco.exec. 参数 includes和excludes可用来选定report中过滤的类。 --&gt; &lt;execution&gt; &lt;id&gt;default-report&lt;/id&gt; &lt;phase&gt;test&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;report&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;dataFile&gt;$&#123;project.build.directory&#125;/coverage-reports/jacoco.exec&lt;/dataFile&gt; &lt;outputDirectory&gt;$&#123;project.reporting.outputDirectory&#125;/jacoco&lt;/outputDirectory&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!-- 使用 maven-surefire-plugin来执行单元测试。 将surefireArgLine赋值给argLine参数，以保证在测试执行时Jacoco agent处于运行状态。 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.19.1&lt;/version&gt; &lt;configuration&gt; &lt;argLine&gt;$&#123;surefireArgLine&#125;&lt;/argLine&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;","tags":[{"name":"jenkins","slug":"jenkins","permalink":"http://yoursite.com/tags/jenkins/"}]},{"title":"docker_jenkins","date":"2019-01-29T02:10:20.000Z","path":"2019/01/29/docker-jenkins/","text":"docker jenkins1拉取镜像1docker pull jenkinsci/jenkins 2根据镜像启动容器1docker run -p 8080:8080 -p 50000:50000 jenkinsci/jenkins 3根据提示去查需要初始的密码12docker exec -it 015fad435af29056b08298af455c9dba0f1289be5e03588022736018a1610d70 bash cat /var/jenkins_home/secrets/initialAdminPassword 4根据界面提示去安装插件5安装ssh key连接gitLab这个时候要注意， 配置的公钥私钥来自于jenkins服务器,注意用jenkins账户生成公钥私钥。 在gitLab的deploy key里配置公钥 在jenkins凭据里配置私钥 然后在jenkins服务器上git clone 下地址，用来测试是不是可以连接到gitLab.如果可以证明配置成功。 gitLab","tags":[{"name":"docker jenkins","slug":"docker-jenkins","permalink":"http://yoursite.com/tags/docker-jenkins/"}]},{"title":"docker example","date":"2019-01-25T07:51:26.000Z","path":"2019/01/25/docker-example/","text":"docker example1234$ tree identidock/identidock/└─ app └─ identidock.py identidock.py1234567from flask import Flaskapp = Flask(__name__) @app.route(&apos;/&apos;) def hello_world(): return &apos;Hello World!\\n&apos;if __name__ == &apos;__main__&apos;: app.run(debug=True, host=&apos;0.0.0.0&apos;) 在 identidock 目录下，创建一个名为Dockerfile 的文件12345FROM python:3.4RUN pip install Flask==0.10.1WORKDIR /appCOPY app /appCMD [&quot;python&quot;, &quot;identidock.py&quot;] 现在，可以构建和运行我们的简单应用了：12345$ cd identidock$ docker build -t identidock ....$ docker run -d -p 5000:5000 identidock0c75444e8f5f16dfe5aceb0aae074cc33dfc06f2d2fb6adb773ac51f20605aa4 我把 -d 选项传给 docker run，让它在后台启动容器，但如果想看到 Web 服务器的输出，也可以把它省略。-p 5000:5000 参数告诉 Docker，我们要将容器的 5000 端口转发到主机上的 5000 端口。 test12$ curl localhost:5000Hello World! 目前这个工作流程有一个比较严重的问题：即使代码只有少许改变，我们也需要重新创建镜像，并且重启容器。幸好，有一个简单的解决方法。我们可以把主机上的源码目录绑定挂载（bind mount）到容器内的源码目录之上。 1docker run -d -p 5000:5000 -v &quot;$PWD&quot;/app:/app identidock -v “$PWD”/app:/app 参数把位于 /app 的 app 目录挂载到容器内。它将覆盖容器中 /app 目录的内容 ，而且在容器内还可以进行读写（如果你不希望这样，也可以把数据卷挂载为只读）。参数 -v 必须是绝对路径，因此在这个例子中，我们在当前的目录前加上 $PWD，","tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"docker常用命令","date":"2019-01-25T07:11:13.000Z","path":"2019/01/25/docker常用命令/","text":"docker常用命令_RUN命令 启动新容器时必然会用到它。因此，它是迄今为止最复杂的命令，能支持非常多的参数。它的选项允许用户配置镜像运行的方式、覆盖 Dockerfile 设置、配置联网，以及设置容器的权限和资源。 命令 描述 -a, –attach 把指定的数据流（如 STDOUT 之类）连接至终端。若未指定，则默认连接 stdout 和 stderr。若数据流未指定，而容器以交互模式（-i）启动，则 stdin 也会被连接至终端。此选项与 -d 选项不兼容-d, –detach|使容器在“分离”模式下运行。容器会在后台运行，而命令的返回值是容器的 ID。-i, –interactive|保持 stdin 打开（即使它没有被被连接至终端 10）。一般与 –t 同时使用，用作启动交互式会话的容器。例如：$ docker run -it debian /bin/bashroot@bd0f26f928bb:/# ls…省略… –restart|配置 Docker 在什么情况下尝试重新启动已退出的容器。参数为 no 意味着永远不会尝试重新启动容器；always 指不管退出状态是什么，总会尝试重新启动；on-failure 仅当退出状态不为 0 的时候才会尝试重启 ，并且可以追加一个可选参数，指定尝试重启的次数，超过重启次数就会放弃（如果没有指定，那就一直重试）。例如，docker run–restart on-failure:10 postgres 将启动 postgres 容器，并当退出值不为 0 的时候，尝试重启最多 10 次。–rm|退出时自动删除容器。不能与 -d 选项同时使用。-t, –tty|分配一个伪终端（pseudo-TTY）。通常与 -i 同时使用，用来启动交互式容器。-e, –env|设置容器内的环境变量。例如：$ docker run -e var1=val -e var2=”val 2” debian envPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binHOSTNAME=b15f833d65d8var1=valvar2=val 2HOME=/root另外，–env-file 选项可以经文件传入环境变量。-h, –hostname NAME|设置容器的 unix 主机名为 NAME。例如：$ docker run -h “myhost” debian hostnamemyhost–name NAME|把 NAME 设置为容器的名称。以后，其他 Docker 命令便可以使用该名称来称呼这个容器。以下选项允许用户进行数据卷的设置-v, –volume|这个选项可以用来设置数据卷（数据卷即一个容器中的文件或目录，实际属于主机的文件系统，而非容器的联合文件系统的一部分），有两种形式的参数可供使用。第一种形式仅指定容器中的目录，Docker 会自行选定一个主机上的目录与之绑定。第二种形式除了指定容器目录，还指定与容器目录绑定的主机目录。–volumes-from|挂载指定容器拥有的数据卷。经常用于数据容器–expose|与 Dockerfile 的 EXPOSE 指令功能一样。指定容器将会使用的端口或端口范围，但并不会把端口打开。只有与 -P 参数同时使用，以及在连接容器时，才有真正意义。–link|建立一个与指定容器连接的内部网络接口。详-p, –publish|“发布”容器的端口，使主机能访问它。若没有指定主机端口，则会随机分配一个高端口，可通过 docker port 命令查看分配了哪个端口。还可以指定端口是在主机的哪个网络接口开放。-P, –publish-all|“发布”所有已指定为开放（exposed）的容器端口，使主机能访问它们。每个容器端口均对应一个随机挑选的高端口。docker port 命令可以用来查看端口之间的映射关系。如果你需要更高级的联网功能，还有几个进阶的选项可用。但请注意，这些选项中有一些要求你对联网有一定了解，以及明白联网在 Docker 中如何实现","tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"gitlab备份还原","date":"2019-01-23T02:48:49.000Z","path":"2019/01/23/gitlab备份还原/","text":"备份跟还原 GitLab应用数据备份创建的压缩文件包含了数据库，所有代码仓库和所有附件。你可以在另一个利用同一个版本的gitLab中回复。通过备份跟恢复是迁移你的仓库从一个服务器到另一个的最好的方式。 需要条件为了能够备份跟恢复，你需要在你的系统中安装2个必要的工具。 Rsync(远程同步工具)如果你已经安装了GitLab: 利用OmniBus包 确保rsync都安装 1234# Debian/Ubuntusudo apt-get install rsync# RHEL/CentOSsudo yum install rsync Tar确保Tar命令在1.3.0以上1tar --version 备份timestamp 在 GitLab 9.2 the timestamp 格式变了从EPOCH_YYYY_MM_DD 到 EPOCH_YYYY_MM_DD_GitLab_version,比如 1493107454_2018_04_25 会变成 1493107454_2018_04_25_10.6.4-ce. Gitlab的备份目录路径设置123456789101112[root@code-server ~]# vim /etc/gitlab/gitlab.rbgitlab_rails[&apos;manage_backup_path&apos;] = truegitlab_rails[&apos;backup_path&apos;] = &quot;/data/gitlab/backups&quot; //gitlab备份目录gitlab_rails[&apos;backup_archive_permissions&apos;] = 0644 //生成的备份文件权限gitlab_rails[&apos;backup_keep_time&apos;] = 7776000 //备份保留天数为3个月（即90天，这里是7776000秒） [root@code-server ~]# mkdir -p /data/gitlab/backups[root@code-server ~]# chown -R git.git /data/gitlab/backups[root@code-server ~]# chmod -R 777 /data/gitlab/backups 如上设置了gitlab备份目录路径为/data/gitlab/backups，最后使用下面命令重载gitlab配置文件，是上述修改生效！root@code-server ~]# gitlab-ctl reconfigure GItlab备份操作（使用备份命令”gitlab-rake gitlab:backup:create”）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253手动备份gitlab[root@code-server backups]# gitlab-rake gitlab:backup:createDumping database ...Dumping PostgreSQL database gitlabhq_production ... [DONE]doneDumping repositories ... * treesign/treesign ... [DONE] * gateway/gateway ... [DONE] * treesign/treesign-doc ... [SKIPPED] * qwsign/qwsign ... [DONE] * qwsign/qwsign-doc ... [DONE] * test/test ... [DONE]doneDumping uploads ...doneDumping builds ...doneDumping artifacts ...doneDumping pages ...doneDumping lfs objects ...doneDumping container registry images ...[DISABLED]Creating backup archive: 1510471890_2017_11_12_9.4.5_gitlab_backup.tar ... doneUploading backup archive to remote storage ... skippedDeleting tmp directories ... donedonedonedonedonedonedonedoneDeleting old backups ... done. (0 removed) 然后查看下备份文件（文件权限是设定好的644）[root@code-server backups]# lltotal 244-rw-r--r-- 1 git git 245760 Nov 12 15:33 1510472027_2017_11_12_9.4.5_gitlab_backup.tar 编写备份脚本，结合crontab实施自动定时备份，比如每天0点、6点、12点、18点各备份一次[root@code-server backups]# pwd/data/gitlab/backups[root@code-server backups]# vim gitlab_backup.sh#!/bin/bash/usr/bin/gitlab-rake gitlab:backup:create CRON=1 注意：环境变量CRON=1的作用是如果没有任何错误发生时， 抑制备份脚本的所有进度输出 [root@code-server backups]# crontab -l0 0,6,12,18 * * * /bin/bash -x /data/gitlab/backups/gitlab_backup.sh &gt; /dev/null 2&gt;&amp;1 Gitlab恢复操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189GItlab只能还原到与备份文件相同的gitlab版本。假设在上面gitlab备份之前创建了test项目，然后不小心误删了test项目，现在就进行gitlab恢复操作： 1）停止相关数据连接服务[root@code-server backups]# gitlab-ctl stop unicornok: down: unicorn: 0s, normally up[root@code-server backups]# gitlab-ctl stop sidekiqok: down: sidekiq: 1s, normally up[root@code-server backups]# gitlab-ctl statusrun: gitaly: (pid 98087) 1883s; run: log: (pid 194202) 163003srun: gitlab-monitor: (pid 98101) 1883s; run: log: (pid 194363) 163002srun: gitlab-workhorse: (pid 98104) 1882s; run: log: (pid 194362) 163002srun: logrotate: (pid 98117) 1882s; run: log: (pid 5793) 160832srun: nginx: (pid 98123) 1881s; run: log: (pid 194359) 163002srun: node-exporter: (pid 98167) 1881s; run: log: (pid 194360) 163002srun: postgres-exporter: (pid 98173) 1881s; run: log: (pid 194204) 163003srun: postgresql: (pid 98179) 1880s; run: log: (pid 194365) 163002srun: prometheus: (pid 98187) 1880s; run: log: (pid 194364) 163002srun: redis: (pid 98230) 1879s; run: log: (pid 194358) 163002srun: redis-exporter: (pid 98234) 1879s; run: log: (pid 194208) 163003sdown: sidekiq: 8s, normally up; run: log: (pid 194437) 163001sdown: unicorn: 21s, normally up; run: log: (pid 194443) 163001s 2）现在通过之前的备份文件进行恢复（必须要备份文件放到备份路径下，这里备份路径我自定义的/data/gitlab/backups，默认的是/var/opt/gitlab/backups）[root@code-server backups]# pwd/data/gitlab/backups[root@code-server backups]# lltotal 244-rw-r--r-- 1 git git 245760 Nov 12 15:33 1510472027_2017_11_12_9.4.5_gitlab_backup.tar Gitlab的恢复操作会先将当前所有的数据清空，然后再根据备份数据进行恢复[root@code-server backups]# gitlab-rake gitlab:backup:restore BACKUP=1510472027_2017_11_12_9.4.5Unpacking backup ... doneBefore restoring the database we recommend removing all existingtables to avoid future upgrade problems. Be aware that if you havecustom tables in the GitLab database these tables and all data will beremoved. Do you want to continue (yes/no)?........ALTER TABLEALTER TABLEALTER TABLEALTER TABLEWARNING: no privileges were granted for &quot;public&quot;GRANT[DONE]doneRestoring repositories ... * treesign/treesign ... [DONE] * gateway/gateway ... [DONE] * treesign/treesign-doc ... [DONE] * qwsign/qwsign ... [DONE] * qwsign/qwsign-doc ... [DONE] * test/test ... [DONE]Put GitLab hooks in repositories dirs [DONE]doneRestoring uploads ...doneRestoring builds ...doneRestoring artifacts ...doneRestoring pages ...doneRestoring lfs objects ...doneThis will rebuild an authorized_keys file.You will lose any data stored in authorized_keys file.Do you want to continue (yes/no)? yes Deleting tmp directories ... donedonedonedonedonedonedonedone[root@code-server backups]# 最后再次启动Gitlab[root@code-server backups]# gitlab-ctl startok: run: gitaly: (pid 98087) 2138sok: run: gitlab-monitor: (pid 98101) 2138sok: run: gitlab-workhorse: (pid 98104) 2137sok: run: logrotate: (pid 98117) 2137sok: run: nginx: (pid 98123) 2136sok: run: node-exporter: (pid 98167) 2136sok: run: postgres-exporter: (pid 98173) 2136sok: run: postgresql: (pid 98179) 2135sok: run: prometheus: (pid 98187) 2135sok: run: redis: (pid 98230) 2134sok: run: redis-exporter: (pid 98234) 2134sok: run: sidekiq: (pid 104494) 0sok: run: unicorn: (pid 104497) 1s[root@code-server backups]# gitlab-ctl statusrun: gitaly: (pid 98087) 2142s; run: log: (pid 194202) 163262srun: gitlab-monitor: (pid 98101) 2142s; run: log: (pid 194363) 163261srun: gitlab-workhorse: (pid 98104) 2141s; run: log: (pid 194362) 163261srun: logrotate: (pid 98117) 2141s; run: log: (pid 5793) 161091srun: nginx: (pid 98123) 2140s; run: log: (pid 194359) 163261srun: node-exporter: (pid 98167) 2140s; run: log: (pid 194360) 163261srun: postgres-exporter: (pid 98173) 2140s; run: log: (pid 194204) 163262srun: postgresql: (pid 98179) 2139s; run: log: (pid 194365) 163261srun: prometheus: (pid 98187) 2139s; run: log: (pid 194364) 163261srun: redis: (pid 98230) 2138s; run: log: (pid 194358) 163261srun: redis-exporter: (pid 98234) 2138s; run: log: (pid 194208) 163262srun: sidekiq: (pid 104494) 4s; run: log: (pid 194437) 163260srun: unicorn: (pid 104497) 4s; run: log: (pid 194443) 163260s 恢复命令完成后，可以check检查一下恢复情况[root@code-server backups]# gitlab-rake gitlab:check SANITIZE=trueChecking GitLab Shell ... GitLab Shell version &gt;= 5.3.1 ? ... OK (5.3.1)Repo base directory exists?default... yesRepo storage directories are symlinks?default... noRepo paths owned by git:root, or git:git?default... yesRepo paths access is drwxrws---?default... yeshooks directories in repos are links: ...5/1 ... ok6/2 ... ok5/3 ... repository is empty12/4 ... ok12/5 ... okRunning /opt/gitlab/embedded/service/gitlab-shell/bin/checkCheck GitLab API access: OKAccess to /var/opt/gitlab/.ssh/authorized_keys: OKSend ping to redis server: OKgitlab-shell self-check successful Checking GitLab Shell ... Finished Checking Sidekiq ... Running? ... yesNumber of Sidekiq processes ... 1 Checking Sidekiq ... Finished Checking Reply by email ... Reply by email is disabled in config/gitlab.yml Checking Reply by email ... Finished Checking LDAP ... LDAP is disabled in config/gitlab.yml Checking LDAP ... Finished Checking GitLab ... Git configured correctly? ... yesDatabase config exists? ... yesAll migrations up? ... yesDatabase contains orphaned GroupMembers? ... noGitLab config exists? ... yesGitLab config up to date? ... yesLog directory writable? ... yesTmp directory writable? ... yesUploads directory exists? ... yesUploads directory has correct permissions? ... yesUploads directory tmp has correct permissions? ... yesInit script exists? ... skipped (omnibus-gitlab has no init script)Init script up-to-date? ... skipped (omnibus-gitlab has no init script)Projects have namespace: ...5/1 ... yes6/2 ... yes5/3 ... yes12/4 ... yes12/5 ... yesRedis version &gt;= 2.8.0? ... yesRuby version &gt;= 2.3.3 ? ... yes (2.3.3)Git version &gt;= 2.7.3 ? ... yes (2.13.4)Active users: ... 11 Checking GitLab ... Finished 然后稍等一会（如果启动gitlab后，访问出现500，这是因为redis等程序还没完全启动，等一会儿访问就ok了），再次登录Gitlab，就会发现之前误删除的test项目已经恢复了！ 另外：Gitlab迁移与恢复一样，但是要求两个GitLab版本号一致","tags":[{"name":"gitlab","slug":"gitlab","permalink":"http://yoursite.com/tags/gitlab/"}]},{"title":"gitlab安装","date":"2019-01-18T02:52:55.000Z","path":"2019/01/18/gitlab安装/","text":"gitLab安装1. 配置系统防火墙,把HTTP和SSH端口开放12345[root@gitlab ~]# /etc/init.d/iptables stop[root@gitlab ~]# yum install curl openssh-server postfix cronie[root@gitlab ~]# service postfix start[root@gitlab ~]# chkconfig postfix on[root@gitlab ~]# lokkit -s http -s ssh 2.下载gitlab的rpm安装包1[root@gitlab ~]# rpm -ivh gitlab-ce-9.4.5-ce.0.el6.x86_64.rpm --force 安装后的gitlab默认路径是/opt/gitlab（程序路径）、 /var/opt/gitlab（配置文件路径）。 issue1234[root@localhost zxg]# rpm -ivh gitlab-ce-10.0.0-ce.0.el6.x86_64.rpm --forcewarning: gitlab-ce-10.0.0-ce.0.el6.x86_64.rpm: Header V4 RSA/SHA1 Signature, key ID f27eab47: NOKEYerror: Failed dependencies:policycoreutils-python is needed by gitlab-ce-10.0.0-ce.0.el6.x86_64 solve1yum install policycoreutils-python 3. 配置端口号 vi /etc/gitlab/gitlab.rb12external_url &apos;http://10.60.45.87&apos;nginx[&apos;listen_port&apos;] = 8081 4. 生效123gitlab-ctl reconfiguregitlab-ctl startgitlab-ctl status","tags":[{"name":"gitlab","slug":"gitlab","permalink":"http://yoursite.com/tags/gitlab/"}]},{"title":"gitLab_Runner","date":"2019-01-18T01:27:52.000Z","path":"2019/01/18/gitLab-Runner/","text":"gitLab 之 Runner Gitlab CI Runner安装以及如何跑项目构建流程。 1. 安装、注册并启动Gitlab RunnerGitlab Runner安装方式有两种，一种是直接二进制文件安装，一种是基于docker镜像安装。 1. 下载对应操作系统的二进制包，我这里使用的是mac版本1sudo curl --output /usr/local/bin/gitlab-runner https://gitlab-ci-multi-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-ci-multi-runner-darwin-amd64 1234 # For RHEL/CentOS/Fedora curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.rpm.sh | sudo bash``` ##### 2. 给gitlab-runner赋可执行权限 sudo chmod +x /usr/local/bin/gitlab-runner1##### 3 注册runner gitlab-runner registerPlease enter the gitlab-ci coordinator URL: 示例：http://gitlab.alibaba-inc.com/ciPlease enter the gitlab-ci token for this runner: xxxxxxPlease enter the gitlab-ci description for this runner: 示例：qd_api_runnerPlease enter the gitlab-ci tags for this runner (comma separated): 示例：hwyWhether to run untagged builds [true/false]: truePlease enter the executor: docker, parallels, shell, kubernetes, docker-ssh, ssh, virtualbox, docker+machine, docker-ssh+machine: dockerPlease enter the default Docker image (e.g. ruby:2.1): maven:3-jdk-81234567说明： 1. gitlab ci的地址以及token，从你要配置该runner到哪个项目，就去gitlab下该项目首页右侧设置—》CI/CD Pipelines—》Specific Runners下可以找到。 2. gitlab-ci tags这个很重要，在项目构建流程yaml文件里面指定tag，就是匹配使用哪个tag的runner，这里我定义了hwy，回头再配置文件里面就指定这个tag。 3. executor：执行者可以有很多种，这里我们使用docker，方便构建执行。 4. Docker image：构建Docker image时填写的image名称，根据项目代码语言不同，指定不同的镜像。我这里项目是java语言的，所以我使用官方maven:3-jdk-8镜像。##### 4. 安装并启动gitlab-runner cd ~gitlab-runner installgitlab-runner start` 注册gitlab-runner时，提示报错：GitLab Runner &gt;= 9.0 can be used ONLY with GitLab CE/EE &gt;= 9.0这个因为默认gitlab runner安装时最新版的，与我们正在使用的gitlab版本不匹配，那么我们找到匹配的gitlab-runner版本安装即可，从这里我们可以找到 Runner和GitLab CE / EE兼容性列表有时runner会连接不上，或者在项目仓库-&gt;设置-&gt;runner里呈灰色，这有可能是runner机器上没有启动gitlab-runner引起的，可以执行ps -ef | grep gitlab看看是否存在gitlab-runner的进程，如果没有则执行gitlab-runner start 命令启动runner服务。若已经配置好了gitlab-runner了，执行commit，pipeline状态一直是pending，并且提示：This build is stuck, because the project doesn’t have any runners online assigned to it. Go to Runners page这个是因为未找到对应的runner导致的，原因一是有可能gitlab-runner注册失败，原因二有可能是.gitlab-ci.yml配置文件里面tags没有匹配到已注册可用的runner。每次maven:3-jdk-8去执行build和test都会重新拉取镜像，下载依赖的jar包，比较耗时耗资源。这是因为docker image每次构建都是在独立的container里， maven的 .m2文件并不会被多次构建公用，这里我们可以通过修改gitlab-runner的配置，将maven .m2目录加到volumes中，并增加镜像拉取规则（默认是从远程拉取镜像，这里修改为优先获取本地镜像，不存在时才去远程拉取镜像）","tags":[{"name":"gitLab","slug":"gitLab","permalink":"http://yoursite.com/tags/gitLab/"}]},{"title":"docker_redis","date":"2019-01-16T11:08:22.000Z","path":"2019/01/16/docker-redis/","text":"docker pull redis 1docker run --name myredis -d redis -d d 参数让容器在后台运行 ####启动客户端1234567891011$ docker run --rm -it --link myredis:redis redis /bin/bashroot@ca38735c5747:/data# redis-cli -h redis -p 6379redis:6379&gt; pingPONGredis:6379&gt; set &quot;abc&quot; 123OKredis:6379&gt; get &quot;abc&quot;&quot;123&quot;redis:6379&gt; exitroot@ca38735c5747:/data# exitexit 能将两个容器神奇地连接在一起，是通过 docker run 命令的 –link myredis:redis 参数实现的。这个参数告诉 Docker 把新容器与现存的“myredis”容器连接起来，并且在新容器中以“redis”作为“myredis”容器的主机名。为了实现这一点，Docker 会在新容器中的 /etc/hosts 里添加一个新条目，把“redis”指向“myredis”的 IP 地址。这样就能够在执行redis-cli 的时候直接使用“redis”作为主机名，而不需想办法找出或传递 Redis 容器的 IP地址给 redis-cli。 我们怎样才能做数据的持久保存和备份？为此，我们不会使用标准的容器文件系统，而是需要一个能够让容器与主机，或容器与其他容器之间轻松共享数据的方式。Docker 通过数据卷（volume）的概念提供了这种方式。数据卷是直接在主机挂载的文件或目录，不属于常规联合文件系统的一部分。 第一种是在 Dockerfile 里使用 VOLUME 指令，第二种是在执行docker run 的时候使用 -v 参数。12345678910111213$ docker run --rm -it --link myredis:redis redis /bin/bashroot@09a1c4abf81f:/data# redis-cli -h redis -p 6379redis:6379&gt; set &quot;persistence&quot; &quot;test&quot;OKredis:6379&gt; saveOKredis:6379&gt; exitroot@09a1c4abf81f:/data# exitexit$ docker run --rm --volumes-from myredis -v $(pwd)/backup:/backup \\ debian cp /data/dump.rdb /backup/$ ls backupdump.rdb $ docker stop myredismyredis$ docker rm -v myredis","tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"docker寄存服务","date":"2019-01-16T07:09:44.000Z","path":"2019/01/16/docker寄存服务/","text":"docker寄存服务(registry) 寄存服务（registry）负责托管和发布镜像的服务，默认为 Docker Hub。 仓库（repository）一组相关镜像（通常是一个应用或服务的不同版本）的集合 标签（tag）仓库中镜像的识别号，由英文和数字组成（如 14.04 或 stable）。 MAINTAINER 指令，这样做是为了给镜像设定作者的联系信息12345FROM debianMAINTAINER John Smith &lt;john@smith.com&gt;RUN apt-get update &amp;&amp; apt-get install -y cowsay fortuneCOPY entrypoint.sh /ENTRYPOINT [&quot;/entrypoint.sh&quot;] 构建与push 项目仓库名称必须用你的 Docker Hub 账户名开头（我的是 amouat），12docker build -t amouat/cowsay .docker push amouat/cowsay 加个冒号可以指定标签1docker build -t amouat/cowsay:stable. 上传完毕后，任何人都可以用 docker pull 命令下载你的镜像（例如 docker pull amouat/cowsay）。1docker pull zxg123/cowsay issue: Docker push image: denied 问题：Docker push image: denied: requested accessto the resource is denied 原因：要先docke login再docker push 解决： [root@localhost website]# docker login Login with your Docker ID to push and pullimages from Docker Hub. If you don’t have a Docker ID, head over tohttps://hub.docker.com to create one. Username: lilei123 Password: Login Succeeded","tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"docker dockerFile","date":"2019-01-16T05:37:08.000Z","path":"2019/01/16/docker-dockerFile/","text":"dockerFile利用 Dockerfile，使创建镜像的过程全部自动化。 Dockerfile Dockerfile 是一个描述如何创建 Docker 镜像所需步骤的文本文件。 123$ mkdir cowsay $ cd cowsay $ touch Dockerfile 编辑Dockerfile12FROM debian:wheezyRUN apt-get update &amp;&amp; apt-get install -y cowsay fortune 执行Dockerfile123$ lsDockerfile$ docker build -t test/cowsay-dockerfile . 最后面那个点代表当前目录下执行docker build创建成功,执行docker1$ docker run test/cowsay-dockerfile /usr/games/cowsay &quot;Moo&quot; 通过利用 Dockerfile 的 ENTRYPOINT 指 令, 我 们 可 以 让 用 户 更 易 于 使 用 这 个 镜 像。ENTRYPOINT 指令让我们指定一个可执行文件，同时还能处理传给 docker run 的参数。在 Dockerfile 的最后加上下面这一行： 1ENTRYPOINT [&quot;/usr/games/cowsay&quot;] 现在再次生成新镜像，以后使用这个新镜像时再也不需要指定 cowsay 命令了： 123$ docker build -t test/cowsay-dockerfile .$ docker run test/cowsay-dockerfile &quot;Moo&quot; 我们可以把 ENTRYPOINT 指定为一个我们自己的脚本创建一个新文件 entrypoint.sh123456#!/bin/bashif [ $# -eq 0 ]; then /usr/games/fortune | /usr/games/cowsay else /usr/games/cowsay &quot;$@&quot;fi 用 chmod +x entrypoint.sh 把文件设为可执行 修改DockerFile1234FROM debianRUN apt-get update &amp;&amp; apt-get install -y cowsay fortuneCOPY entrypoint.sh / ENTRYPOINT [&quot;/entrypoint.sh&quot;] 测试执行123docker build -t test/cowsay-dockerfile .docker run test/cowsay-dockerfiledocker run test/cowsay-dockerfile Hello Moo","tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"docker容器运行apt-get update失败Temporary failure resolving","date":"2019-01-16T03:45:04.000Z","path":"2019/01/16/docker容器运行apt-get-update失败Temporary-failure-resolving/","text":"Ubuntu中docker容器运行apt-get update失败Temporary failure resolving1sudo systemctl restart docker 试过了添加nameserver到/etc/resolve.conf还是不行，最后重启docker，问题解决了。。。 一开始是简单粗暴地改写域名解析文件：1python -c &quot;s=&apos;nameserver 114.114.114.114&apos;;fname=&apos;/etc/resolv.conf&apos;;fp=open(fname);ss=fp.read();fp.close();fp=open(fname, &apos;w&apos;);fp.write(&apos;&#123;s&#125;\\n&#123;ss&#125;&apos;.format(s=s,ss=ss));fp.close()&quot; 结果在容器运行时有作用，在创建容器时还是会出问题，所以还是要重启docker","tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"docker IPv4 forwarding is disabled","date":"2019-01-16T02:42:27.000Z","path":"2019/01/16/docker-IPv4-forwarding-is-disabled/","text":"centos 7 docker 启动了一个web服务 但是启动时 报 WARNING: IPv4 forwarding is disabled. Networking will not work. 网上查询了下 需要做如下配置 解决办法： vi /etc/sysctl.conf 或者 vi /usr/lib/sysctl.d/00-system.conf 添加如下代码： net.ipv4.ip_forward=1 重启network服务 systemctl restart network 查看是否修改成功 sysctl net.ipv4.ip_forward 如果返回为“net.ipv4.ip_forward = 1”则表示成功了","tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"linux iptables","date":"2019-01-16T02:25:29.000Z","path":"2019/01/16/linux-iptables/","text":"解决centos7中使用service iptables stop 显示not loadedcentos从7开始默认用的是firewalld，这个是基于iptables的，虽然有iptables的核心，但是iptables的服务是没安装的。所以你只要停止firewalld服务即可：sudo systemctl stop firewalld.service &amp;&amp; sudo systemctl disable firewalld.service 如果你要改用iptables的话，需要安装iptables服务：sudo yum install iptables-servicessudo systemctl enable iptables &amp;&amp; sudo systemctl enable ip6tablessudo systemctl start iptables &amp;&amp; sudo systemctl start ip6tables","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"docker基本命令","date":"2019-01-15T12:33:17.000Z","path":"2019/01/15/docker基本命令/","text":"sonar为容器名称 1docker inspect sonar sonar容器信息 1docker diff sonar sonar容器最近修改信息 1234docker logs sonardocker logs -t sonardocker logs -tf sonardocker logs -tf --tail 0 sonar sonar删除容器 1docker rm sonar 清理已停止的容器 1docker rm -v $(docker ps -aq -f status=exited) 在运行中的容器内启动新进程 1docker exec -i -t container /bin/bash 把cowsay应用docker化 123456789101112131415161718192021222324 docker run -it --name cowsay --hostname cowsay debian bash apt-get update apt-get install -y cowsay fortune /usr/games/fortune | /usr/games/cowsay / Writing is easy; all you do is sit \\| staring at the blank sheet of paper || until drops of blood form on your || forehead. || |\\ -- Gene Fowler / ------------------------------------- \\ ^__^ \\ (oo)\\_______ (__)\\ )\\/\\ ||---w | || || 要把它转成镜像的话，执行 docker commit cowsay test/cowsayimage 命令的返回值是这个镜像的唯一识别码（unique ID）。现在，我们创建了一个能随时使用， 并且已安装 cowsay 的镜像： docker run test/cowsayimage /usr/games/cowsay &quot;Moo&quot;","tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"linux常用命令","date":"2019-01-14T09:45:53.000Z","path":"2019/01/14/linux常用命令/","text":"######## linux 常用命令 ######网络断了启动网络 service network startkill -9 ps -ef|grep firefox|grep -v grep|awk &#39;{print $2}&#39; 查看某端口占用的线程的pid netstat -nlp |grep :9181","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"docker_python","date":"2019-01-11T07:38:36.000Z","path":"2019/01/11/docker-python/","text":"docker run -v $PWD:/usr/src/myapp -w /usr/src/myapp python:3.5 python helloworld.py","tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"docker安装 mysql","date":"2019-01-10T02:16:06.000Z","path":"2019/01/10/docker/","text":"docker 安装 mysql‘’’ docker 中下载 mysqldocker pull mysql #启动docker run –name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=Lzslov123! -d mysql #进入容器docker exec -it mysql bash #登录mysqlmysql -u root -pALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘Lzslov123!’; #添加远程登录用户CREATE USER ‘liaozesong‘@’%’ IDENTIFIED WITH mysql_native_password BY ‘Lzslov123!’;或者 CREATE USER ‘liaozesong‘@’%’ IDENTIFIED BY ‘Lzslov123!’;GRANT ALL PRIVILEGES ON . TO ‘liaozesong‘@’%’;‘’’","tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"centos7","date":"2019-01-09T09:17:58.000Z","path":"2019/01/09/centos7/","text":"centos7 初始化安装刚开始安装用mini版本，所以很多需要安装的库都没安装，首先会出现输入ifconfig没有对应的值ifconfig1yum install net-tools","tags":[{"name":"centos7,linux","slug":"centos7-linux","permalink":"http://yoursite.com/tags/centos7-linux/"}]},{"title":"python_os 详解","date":"2019-01-09T09:17:58.000Z","path":"2019/01/09/python_os/","text":"获取项目根目录绝对路径‘’’projectDir = os.path.dirname(os.path.dirname(os.path.abspath(file)))‘’’ python 初始化安装os.sep:取代操作系统特定的路径分隔符os.name:指示你正在使用的工作平台。比如对于Windows，它是’nt’，而对于Linux/Unix用户，它是’posix’。os.getcwd:得到当前工作目录，即当前python脚本工作的目录路径。os.getenv()和os.putenv:分别用来读取和设置环境变量os.listdir():返回指定目录下的所有文件和目录名os.remove(file):删除一个文件os.stat（file）:获得文件属性os.chmod(file):修改文件权限和时间戳os.mkdir(name):创建目录os.rmdir(name):删除目录os.removedirs（r“c：\\python”）:删除多个目录os.system():运行shell命令os.exit():终止当前进程os.linesep:给出当前平台的行终止符。例如，Windows使用’\\r\\n’，Linux使用’\\n’而Mac使用’\\r’os.path.split():返回一个路径的目录名和文件名os.path.isfile()和os.path.isdir()分别检验给出的路径是一个目录还是文件os.path.existe():检验给出的路径是否真的存在os.listdir(dirname):列出dirname下的目录和文件os.getcwd():获得当前工作目录os.curdir:返回当前目录（’.’）os.chdir(dirname):改变工作目录到dirnameos.path.isdir(name):判断name是不是目录，不是目录就返回falseos.path.isfile(name):判断name这个文件是否存在，不存在返回falseos.path.exists(name):判断是否存在文件或目录nameos.path.getsize(name):或得文件大小，如果name是目录返回0Los.path.abspath(name):获得绝对路径os.path.isabs():判断是否为绝对路径os.path.normpath(path):规范path字符串形式os.path.split(name):分割文件名与目录（事实上，如果你完全使用目录，它也会将最后一个目录作为文件名而分离，同时它不会判断文件或目录是否存在）os.path.splitext():分离文件名和扩展名os.path.join(path,name):连接目录与文件名或目录os.path.basename(path):返回文件名os.path.dirname(path):返回文件路径 文件操作os.mknod(“text.txt”)：创建空文件fp = open(“text.txt”,w):直接打开一个文件，如果文件不存在就创建文件 关于open的模式fp.read([size]) #size为读取的长度，以byte为单位fp.readline([size]) #读一行，如果定义了size，有可能返回的只是一行的一部分fp.readlines([size]) #把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。fp.write(str) #把str写到文件中，write()并不会在str后加上一个换行符fp.writelines(seq) #把seq的内容全部写到文件中(多行一次性写入)。这个函数也只是忠实地写入，不会在每行后面加上任何东西。fp.close() #关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。 如果一个文件在关闭后还对其进行操作会产生ValueErrorfp.flush() #把缓冲区的内容写入硬盘fp.fileno() #返回一个长整型的”文件标签“fp.isatty() #文件是否是一个终端设备文件（unix系统中的）fp.tell() #返回文件操作标记的当前位置，以文件的开头为原点fp.next() #返回下一行，并将文件操作标记位移到下一行。把一个file用于for … in file这样的语句时，就是调用next()函数来实现遍历的。fp.seek(offset[,whence]) #将文件打操作标记移到offset的位置。这个offset一般是相对于文件的开头来计算的，一般为正数。但如果提供了whence参数就不一定了，whence可以为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。需要注意，如果文件以a或a+的模式打开，每次进行写操作时，文件操作标记会自动返回到文件末尾。fp.truncate([size]) #把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。如果size比文件的大小还要大，依据系统的不同可能是不改变文件，也可能是用0把文件补到相应的大小，也可能是以一些随机的内容加上去。 目录操作os.mkdir(“file”) 创建目录shutil.copyfile(“oldfile”,”newfile”) 复制文件:oldfile和newfile都只能是文件shutil.copy(“oldfile”,”newfile”) oldfile只能是文件夹，newfile可以是文件，也可以是目标目录shutil.copytree(“olddir”,”newdir”) 复制文件夹.olddir和newdir都只能是目录，且newdir必须不存在os.rename(“oldname”,”newname”) 重命名文件（目录）.文件或目录都是使用这条命令shutil.move(“oldpos”,”newpos”) 移动文件（目录os.rmdir(“dir”) 只能删除空目录shutil.rmtree(“dir”) 空目录、有内容的目录都可以删os.chdir(“path”) 转换目录，换路径","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"你好,世界","date":"2019-01-04T01:54:11.000Z","path":"2019/01/04/你好-世界/","text":"先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必能裨补阙漏，有所广益。","tags":[]}]